minerva.losses.topological_loss
===============================

.. py:module:: minerva.losses.topological_loss


Classes
-------

.. autoapisummary::

   minerva.losses.topological_loss.AlephPersistenHomologyCalculation
   minerva.losses.topological_loss.PersistentHomologyCalculation
   minerva.losses.topological_loss.TopologicalLoss
   minerva.losses.topological_loss.TopologicalSignatureDistance
   minerva.losses.topological_loss.UnionFind


Module Contents
---------------

.. py:class:: AlephPersistenHomologyCalculation(compute_cycles, sort_selected)

   
   Calculate persistent homology using aleph.

   Args:
       compute_cycles: Whether to compute cycles
       sort_selected: Whether to sort the selected pairs using the
           distance matrix (such that they are in the order of the
           filteration)


   .. py:method:: __call__(distance_matrix)

      Do PH calculation.

      Args:
          distance_matrix: numpy array of distances

      Returns: tuple(edge_featues, cycle_features)



   .. py:attribute:: compute_cycles


   .. py:attribute:: sort_selected


.. py:class:: PersistentHomologyCalculation

   .. py:method:: __call__(matrix)


.. py:class:: TopologicalLoss(p = 2)

   Bases: :py:obj:`torch.nn.modules.loss._Loss`


   Base class for all neural network modules.

   Your models should also subclass this class.

   Modules can also contain other Modules, allowing them to be nested in
   a tree structure. You can assign the submodules as regular attributes::

       import torch.nn as nn
       import torch.nn.functional as F

       class Model(nn.Module):
           def __init__(self) -> None:
               super().__init__()
               self.conv1 = nn.Conv2d(1, 20, 5)
               self.conv2 = nn.Conv2d(20, 20, 5)

           def forward(self, x):
               x = F.relu(self.conv1(x))
               return F.relu(self.conv2(x))

   Submodules assigned in this way will be registered, and will also have their
   parameters converted when you call :meth:`to`, etc.

   .. note::
       As per the example above, an ``__init__()`` call to the parent class
       must be made before assignment on the child.

   :ivar training: Boolean represents whether this module is in training or
                   evaluation mode.
   :vartype training: bool

   Initialize the TopologicalLoss class.

   Parameters
   ----------
   p : int, optional
       Order of norm used for distance computation, by default 2


   .. py:method:: _compute_distance_matrix(x, p=2)
      :staticmethod:



   .. py:method:: forward(x, x_encoded)


   .. py:attribute:: latent_norm


   .. py:attribute:: p
      :value: 2



   .. py:attribute:: topological_signature_distance


.. py:class:: TopologicalSignatureDistance(sort_selected=False, use_cycles=False, match_edges=None)

   Bases: :py:obj:`torch.nn.Module`


   Topological signature.

   Topological signature computation.

   Args:
       p: Order of norm used for distance computation
       use_cycles: Flag to indicate whether cycles should be used
           or not.


   .. py:method:: _count_matching_pairs(pairs1, pairs2)
      :staticmethod:



   .. py:method:: _get_nonzero_cycles(pairs)
      :staticmethod:



   .. py:method:: _get_pairings(distances)


   .. py:method:: _select_distances_from_pairs(distance_matrix, pairs)


   .. py:method:: forward(distances1, distances2)

      Return topological distance of two pairwise distance matrices.

      Args:
          distances1: Distance matrix in space 1
          distances2: Distance matrix in space 2

      Returns:
          distance, dict(additional outputs)



   .. py:attribute:: match_edges
      :value: None



   .. py:method:: sig_error(signature1, signature2)
      :staticmethod:


      Compute distance between two topological signatures.



   .. py:attribute:: signature_calculator


   .. py:attribute:: use_cycles
      :value: False



.. py:class:: UnionFind(n_vertices)

   An implementation of a Union--Find class. The class performs path
   compression by default. It uses integers for storing one disjoint
   set, assuming that vertices are zero-indexed.

   Initializes an empty Union--Find data structure for a given
   number of vertices.


   .. py:attribute:: _parent


   .. py:method:: find(u)

      Finds and returns the parent of u with respect to the hierarchy.



   .. py:method:: merge(u, v)

      Merges vertex u into the component of vertex v. Note the
      asymmetry of this operation.



   .. py:method:: roots()

      Generator expression for returning roots, i.e. components that
      are their own parents.



