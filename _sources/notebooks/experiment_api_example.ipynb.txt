{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Minerva Experimental Pipeline\n",
    "\n",
    "One of Minerva’s core features are regarding reproducibility and experiment management. In this notebook, we will show how to use the `Experiment` class run and manage experiments in a structured way. \n",
    "This class implements a Minerva pipeline that allows you to run experiments in a reproducible manner, while also providing a convenient interface for managing and analyzing the results.\n",
    "\n",
    "\n",
    "We will cover the following topics:\n",
    "\n",
    "1. **The ModelInstantiator Interface**: Learn how to instantiate models for supervised learning, fine-tuning, or evaluation in a consistent and modular way.\n",
    "\n",
    "2. **Attaching Metadata**: Add informative metadata to your experiments, such as model and dataset names.\n",
    "\n",
    "3. **Using the Experiment Class**: Understand how to run, save, and reload experiments using Minerva’s `Experiment` class, which provides a unified interface for experiment lifecycle management.\n",
    "\n",
    "4. **Loading and Analyzing Results**: Retrieve predictions, metrics, and other results from completed experiments for analysis and comparison.\n",
    "\n",
    "\n",
    "In this example, we will create a Experiment using DeepLabV3 to perform semantic segmentation on F3 dataset, based on the [Seismic Facies Segmentation Getting Started example](seismic_facies_getting_started.ipynb). You may want to check that example first to understand the dataset and the model we are using here.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Overview of the Experiment class\n",
    "\n",
    "The `Experiment` class is designed to manage the lifecycle of an experiment, from instantiation to execution, evaluation and result analysis. \n",
    "Thus, it can be used to:\n",
    "\n",
    "- Train or finetune a model.\n",
    "- Save checkpoints and logs, as well evaluate the model on different checkpoint states.\n",
    "- Save and load experiment results and predictions.\n",
    "\n",
    "Below is a diagram that illustrates the main components of the `Experiment` class and its interactions with other parts of the Minerva framework.\n",
    "There are several parameters, some of them are optional and some others were ommited in the diagram. We show the most important ones here.\n",
    "\n",
    "![Experiment class overview](../figures/experiment_diagram.png)\n",
    "\n",
    "The `Experiment` class serves as a high-level interface for managing supervised learning and fine-tuning workflows in Minerva. It integrates model configuration, data handling, training logic, evaluation metrics, and result logging into a unified structure.\n",
    "\n",
    "The class is composed of several key components:\n",
    "\n",
    "* **experiment_name** (`str`): A unique identifier for the experiment. This is used to create a dedicated directory where logs, results, and predictions will be saved.\n",
    "\n",
    "* **model_config** (`ModelConfig`): An instance of the `ModelConfig` class containing all necessary configuration details for model creation—whether initializing from scratch or fine-tuning.\n",
    "\n",
    "* **data_module** (`MinervaDataModule`): An instance of the `MinervaDataModule` class that provides the training, validation, and test datasets.\n",
    "\n",
    "* **pretrained_backbone_path** (`str`, optional): A file path to a pretrained backbone model. If provided, the model is initialized with weights from this checkpoint via `ModelInstantiator.create_model_and_load_backbone`, enabling fine-tuning. If not provided, the model is initialized from scratch using `ModelInstantiator.create_model_randomly_initialized`, which supports training from the ground up.\n",
    "\n",
    "* **root_log_dir** (`str`, optional): The root directory where experiment-related artifacts (logs, results, checkpoints, etc.) will be saved.\n",
    "\n",
    "* **execution_id** (`str` or `int`, optional): A unique identifier for the specific execution run of the experiment. Useful for distinguishing between multiple runs of the same experiment.\n",
    "\n",
    "* **checkpoint_metrics** (`List[Dict]`, optional): A list of dictionaries defining model checkpointing behavior. It will be used to create lightning `ModelCheckpoint` callbacks. Each dictionary must include:\n",
    "\n",
    "  * `\"monitor\"`: The metric to monitor (e.g., `\"val_loss\"`).\n",
    "  * `\"mode\"`: `\"min\"` or `\"max\"`, indicating whether the monitored metric should be minimized or maximized.\n",
    "  * `\"filename\"`: The filename for saving the checkpoint.\n",
    "  * If `\"monitor\"` is `None`, the checkpoint will correspond to the final model state. Defaults to `None`.\n",
    "\n",
    "* **max_epochs** (`int`, optional): The maximum number of training epochs. Training will terminate once this limit is reached.\n",
    "\n",
    "* **evaluation_metrics** (`Dict[str, torchmetrics.Metric]`, optional): A dictionary of evaluation metrics applied globally across the entire dataset. Each metric is computed on the aggregate predictions.\n",
    "\n",
    "* **per_sample_evaluation_metrics** (`Dict[str, torchmetrics.Metric]`, optional): A dictionary of metrics evaluated individually per sample. Useful for tasks requiring per-instance performance monitoring.\n",
    "\n",
    "* **save_predictions** (`bool`, default=`True`): Whether to save the predictions generated during evaluation. Saved predictions will be stored in the experiment directory.\n",
    "\n",
    "* **save_results** (`bool`, default=`True`): If enabled, the final results will be saved to the log directory.\n",
    "\n",
    "* **add_last_checkpoint** (`bool`, default=`True`): If `True`, the last model checkpoint (i.e., the final state after training) will be included in the checkpoint list, even if it's not associated with a specific monitored metric.\n",
    "\n",
    "\n",
    "Minerva's `Experiment` class is built to support both training from scratch and fine-tuning workflows. By toggling the `pretrained_backbone_path`, users can seamlessly switch between initializing models with pretrained weights or random parameters. This flexibility makes the class adaptable to a wide range of machine learning scenarios."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### The `ModelInstantiator` Interface\n",
    "\n",
    "The `ModelInstantiator` interface is a central component in the Minerva Experimental Pipeline for enabling flexible and consistent model creation across supervised learning and fine-tuning workflows. It serves as an **abstract class for lazy model instantiation**, allowing models to be constructed only when needed, with or without pretrained components.\n",
    "\n",
    "Minerva assumes that all models conform to the following modular design:\n",
    "\n",
    "```\n",
    "+-------------------------------+\n",
    "|     Model (LightningModule)   |\n",
    "|                               |\n",
    "|     +-----------------+       |\n",
    "|     |    Backbone     |       |   --> Feature extractor\n",
    "|     +-----------------+       |\n",
    "|             |                 |\n",
    "|             v                 |\n",
    "|        +----------+           |\n",
    "|        |   Head   |           |   --> Task-specific layers\n",
    "|        +----------+           |\n",
    "+-------------------------------+\n",
    "```\n",
    "\n",
    "This structure separates the **backbone** (typically a pretrained feature extractor) from the **head** (task-specific layers), facilitating easy reuse and fine-tuning.\n",
    "\n",
    "\n",
    "The `ModelInstantiator` interface defines a standardized mechanism to build models across three primary scenarios:\n",
    "\n",
    "1. **Training from scratch**: Both the backbone and head are randomly initialized.\n",
    "2. **Fine-tuning**: A pretrained backbone is loaded from a checkpoint, and the head is newly initialized for the target task.\n",
    "3. **Inference/Evaluation**: The full model (backbone and head) is loaded from a previously saved checkpoint.\n",
    "\n",
    "To support this integration, each model must implement a `ModelInstantiator` subclass that defines the following methods:\n",
    "\n",
    "| Method                                                     | Parameters                         | Description                                                                                                                                             |\n",
    "| ---------------------------------------------------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n",
    "| `create_model_randomly_initialized()`                      | None                               | Instantiates a model with both backbone and head **randomly initialized**. Used when training from scratch.                                             |\n",
    "| `create_model_and_load_backbone(backbone_checkpoint_path)` | `backbone_checkpoint_path` (`str`) | Instantiates a model for **fine-tuning**. Loads the backbone from the specified checkpoint and attaches a **new head** initialized for the target task. |\n",
    "| `load_model_from_checkpoint(checkpoint_path)`              | `checkpoint_path` (`str`)          | Loads the **entire model** (both backbone and head) from a checkpoint. Typically used for **evaluation, inference, or resuming training**.              |\n",
    "\n",
    "\n",
    "> **NOTE**: If `pretrained_backbone_path` is to `Experiment` constructor, the `create_model_and_load_backbone` method will be called with the provided path as the `backbone_checkpoint_path` argument. Else the `create_model_randomly_initialized` method will be called.\n",
    "\n",
    "\n",
    "### The `ModelConfig` Class\n",
    "\n",
    "The `ModelConfig` class serves as a high-level configuration object for managing model setup within the Minerva Experimental Pipeline. Instead of passing a model instance directly, the `Experiment` class expects a `ModelConfig` instance that encapsulates both **model creation logic** and **descriptive metadata**.\n",
    "\n",
    "`ModelConfig` includes two key components:\n",
    "\n",
    "1. **ModelInstantiator**: Responsible for **creating the model instance** in different scenarios—training from scratch, fine-tuning with a pretrained backbone, or loading from a checkpoint for evaluation. This interface enables lazy and flexible model instantiation, as described in the previous section.\n",
    "\n",
    "2. **ModelInformation**: A metadata container that holds descriptive information about the model. This includes the model's name, type, version, and any other relevant details that may be useful for logging, tracking, or analysis.\n",
    "\n",
    "In `ModelInformation`, the only required field is `name`, which serves as the unique identifier for the model. All other fields are optional and can be used to provide additional context. While optional in the `Experiment` class, subclasses may require certain fields in `ModelInformation` to be set, depending on the specific logic of the training or evaluation workflow.\n",
    "\n",
    "\n",
    "### Experiment Logging\n",
    "\n",
    "The `Experiment` class provides a structured way to save and log various artifacts related to the experiment. \n",
    "In general, for each execution of the experiment the following directory structure is created:\n",
    "\n",
    "```\n",
    "root_log_dir/\n",
    "└── experiment_name/\n",
    "   └── data_module.name\n",
    "        └── model_information.name\n",
    "           └── execution_id/\n",
    "              ├── metrics.csv\n",
    "              ├── checkpoints/\n",
    "              ├── predictions/\n",
    "              └── results/\n",
    "``` \n",
    "\n",
    "- **metrics.csv**: A CSV file containing the metrics collected during training. This file serves as a summary of the experiment's performance, logged with Lightning logger (e.g., training loss, etc.). It can be used for further analysis or visualization.\n",
    "- **checkpoints/**: Contains model checkpoints saved during training. Each checkpoint corresponds to a specific state of the model, allowing for easy resumption or evaluation.\n",
    "- **predictions/**: Contains the predictions generated by the model during evaluation. This allows for easy access to the model's output for further analysis.\n",
    "- **results/**: Stores the final results of the experiment, including metrics and evaluation scores. This provides a summary of the experiment's performance.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Example: Using the `Experiment` Class for Seismic Facies Segmentation\n",
    "\n",
    "In this example, we'll demonstrate how to use the `Experiment` class in Minerva to perform semantic segmentation on the F3 dataset using the DeepLabV3 model. This builds upon the [Seismic Facies Segmentation Getting Started example](seismic_facies_getting_started.ipynb), so it's recommended to review that notebook first to understand the dataset and model components being reused here.\n",
    "\n",
    "In general, this notebook encapsulates the process of training a DeepLabV3 model on the F3 dataset from [Seismic Facies Segmentation Getting Started example](seismic_facies_getting_started.ipynb) into a structured pipeline using the `Experiment` class.\n",
    "\n",
    "The notebook is organized into the following sections:\n",
    "\n",
    "1. **Data Preparation**: Using the `MinervaDataModule` from the previous example\n",
    "2. **Model Setup**: Creating the `ModelInstantiator` and `ModelConfig` classes\n",
    "3. **Experiment Definition**: Building the custom `Experiment` class\n",
    "4. **Training and Evaluate Model**: Running the experiment\n",
    "5. **Managing Results and Lifecycle**: Saving and loading results, and also experiment lifecycle management\n",
    "6. **Cleanup**: Cleaning up the experiment directory"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "import numpy as np\n",
    "import lightning as L\n",
    "import torch\n",
    "from torchmetrics import JaccardIndex\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "from minerva.data.readers.patched_array_reader import NumpyArrayReader\n",
    "from minerva.transforms.transform import Repeat, Squeeze\n",
    "from minerva.data.datasets.base import SimpleDataset\n",
    "from minerva.models.nets.image.deeplabv3 import DeepLabV3\n",
    "from minerva.models.loaders import FromPretrained\n",
    "from minerva.utils.typing import PathLike\n",
    "from minerva.data.data_modules.base import MinervaDataModule\n",
    "from minerva.pipelines.experiment import ModelConfig, ModelInstantiator, ModelInformation, Experiment"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1. Data Preparation\n",
    "\n",
    "In this section, we will create a `MinervaDataModule` for the F3 dataset, as we did in the [Seismic Facies Segmentation Getting Started example](seismic_facies_getting_started.ipynb), using data from the F3 dataset.\n",
    "\n",
    "Thus, it will:\n",
    "1. Create the train data and labels readers and create the train dataset.\n",
    "2. Create the test data and labels readers and create the test dataset.\n",
    "3. Create a `MinervaDataModule` instance with the train and test datasets."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "==================================================\n",
      "           📂 SimpleDataset Information            \n",
      "==================================================\n",
      "📌 Dataset Type: SimpleDataset\n",
      "   └── Reader 0: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=float64)\n",
      "   │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "   └── Reader 1: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=uint8)\n",
      "   │     └── Transform: None\n",
      "   │\n",
      "   └── Total Readers: 2\n",
      "==================================================\n"
     ]
    }
   ],
   "source": [
    "# 1. Create the train data and labels readers and create the train dataset.\n",
    "\n",
    "root_data_dir = Path(\"datasets/f3/data/\")\n",
    "\n",
    "# ----- TRAIN DATA AND LABEL READERS -----\n",
    "train_data_reader = NumpyArrayReader(\n",
    "    data=root_data_dir / \"train\" / \"train_seismic.npy\",\n",
    "    data_shape=(1, 701, 255),\n",
    ")\n",
    "\n",
    "train_labels_reader = NumpyArrayReader(\n",
    "    data=root_data_dir / \"train\" / \"train_labels.npy\",\n",
    "    data_shape=(1, 701, 255),\n",
    ")\n",
    "\n",
    "# ----- TRAIN DATASET -----\n",
    "train_dataset = SimpleDataset(\n",
    "    readers=[\n",
    "        train_data_reader,  # 1st reader is the data\n",
    "        train_labels_reader # 2nd reader is the labels\n",
    "    ],\n",
    "    transforms=[\n",
    "        Repeat(axis=0, n_repetitions=3),  # Transforms to first reader (data)\n",
    "        None                              # Transforms to second reader (labels)\n",
    "    ],\n",
    ")\n",
    "\n",
    "print(train_dataset)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "==================================================\n",
      "           📂 SimpleDataset Information            \n",
      "==================================================\n",
      "📌 Dataset Type: SimpleDataset\n",
      "   └── Reader 0: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=float64)\n",
      "   │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "   └── Reader 1: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=uint8)\n",
      "   │     └── Transform: Squeeze(axis=0)\n",
      "   │\n",
      "   └── Total Readers: 2\n",
      "==================================================\n"
     ]
    }
   ],
   "source": [
    "# 2. Create the test data and labels readers and create the test dataset.\n",
    "\n",
    "# ----- TEST DATA AND LABEL READERS -----\n",
    "test_data_reader = NumpyArrayReader(\n",
    "    data=root_data_dir / \"test_once\" / \"test1_seismic.npy\",\n",
    "    data_shape=(1, 701, 255),\n",
    ")\n",
    "\n",
    "test_labels_reader = NumpyArrayReader(\n",
    "    data=root_data_dir / \"test_once\" / \"test1_labels.npy\",\n",
    "    data_shape=(1, 701, 255),\n",
    ")\n",
    "\n",
    "# ----- TEST DATASET -----\n",
    "test_dataset = SimpleDataset(\n",
    "    readers=[test_data_reader, test_labels_reader],\n",
    "    transforms=[Repeat(axis=0, n_repetitions=3), Squeeze(0)],\n",
    ")\n",
    "\n",
    "print(test_dataset)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "==================================================\n",
      "                    🆔 F3_Dataset\n",
      "==================================================\n",
      "└── Predict Split: test\n",
      "📂 Datasets:\n",
      "   ├── Train Dataset:\n",
      "   │      ==================================================\n",
      "   │                 📂 SimpleDataset Information            \n",
      "   │      ==================================================\n",
      "   │      📌 Dataset Type: SimpleDataset\n",
      "   │         └── Reader 0: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=float64)\n",
      "   │         │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "   │         └── Reader 1: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=uint8)\n",
      "   │         │     └── Transform: None\n",
      "   │         │\n",
      "   │         └── Total Readers: 2\n",
      "   │      ==================================================\n",
      "   ├── Val Dataset:\n",
      "   │      None\n",
      "   └── Test Dataset:\n",
      "          ==================================================\n",
      "                     📂 SimpleDataset Information            \n",
      "          ==================================================\n",
      "          📌 Dataset Type: SimpleDataset\n",
      "             └── Reader 0: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=float64)\n",
      "             │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "             └── Reader 1: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=uint8)\n",
      "             │     └── Transform: Squeeze(axis=0)\n",
      "             │\n",
      "             └── Total Readers: 2\n",
      "          ==================================================\n",
      "\n",
      "🛠 **Dataloader Configurations:**\n",
      "   ├── Dataloader class: <class 'torch.utils.data.dataloader.DataLoader'>\n",
      "   ├── Train Dataloader Kwargs:\n",
      "         ├── batch_size: 16\n",
      "         ├── num_workers: 4\n",
      "         ├── shuffle: true\n",
      "         ├── drop_last: true\n",
      "   ├── Val Dataloader Kwargs:\n",
      "         ├── batch_size: 16\n",
      "         ├── num_workers: 4\n",
      "         ├── shuffle: false\n",
      "         ├── drop_last: false\n",
      "   └── Test Dataloader Kwargs:\n",
      "         ├── batch_size: 16\n",
      "         ├── num_workers: 4\n",
      "         ├── shuffle: false\n",
      "         ├── drop_last: false\n",
      "==================================================\n"
     ]
    }
   ],
   "source": [
    "# 3. Create a `MinervaDataModule` instance with the train and test datasets.\n",
    "\n",
    "# ---- DATA MODULE -----\n",
    "data_module = MinervaDataModule(\n",
    "    train_dataset=train_dataset,\n",
    "    test_dataset=test_dataset,\n",
    "    batch_size=16,\n",
    "    num_workers=4,\n",
    "    additional_train_dataloader_kwargs={\"drop_last\": True},\n",
    "    name=\"F3_Dataset\"\n",
    ")\n",
    "\n",
    "print(data_module)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2. Model Setup\n",
    "\n",
    "We will use DeepLabV3 as the model for semantic segmentation. As `Experiment` class requires a `ModelConfig` instance, we will create a custom `ModelInstantiator` and `ModelConfig` classes to encapsulate the model creation logic and metadata.\n",
    "\n",
    "Thus, we will:\n",
    "1. Create a custom `ModelInstantiator` class that implements the `create_model_randomly_initialized` and `load_model_from_checkpoint` methods. We will not implement the `create_model_and_load_backbone` method, as we will not use a pretrained backbone in this example.\n",
    "2. Create a `ModelInformation` instance to hold metadata about the model, such as its name and type.\n",
    "3. Create a custom `ModelConfig` class using the `ModelInstantiator` and `ModelInformation` instances. This class will be passed to the `Experiment` class to create the model."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### ModelInstantiator for DeepLabV3\n",
    "\n",
    "Let's define a custom `ModelInstantiator` class for the DeepLabV3 architecture. This class will implement the methods: `create_model_randomly_initialized`, and `load_model_from_checkpoint`. These methods allow the model to be either initialized from scratch or loaded from a checkpoint.\n",
    "\n",
    "Instantiators are designed to be reusable across multiple experiments that use the same model architecture. However, it’s common to define different instantiators when the model’s backbone is loaded in different ways, for example:\n",
    "\n",
    "* One `ModelInstantiator` for a DeepLabV3 model pretrained with **SimCLR**\n",
    "* Another for a DeepLabV3 model pretrained with **BYOL**\n",
    "\n",
    "This distinction is necessary whenever the loading process for the backbone differs, for instance, if the parameter names or checkpoint structures do not align. In such cases, a custom loading strategy is required, which is encapsulated in the corresponding instantiator.\n",
    "\n",
    "Let's implement a very simple `ModelInstantiator` for the DeepLabV3 model, that can be customizable with different number of classes."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<__main__.DeepLabV3_Instantiator object at 0x70280d8f7dc0>\n"
     ]
    }
   ],
   "source": [
    "class DeepLabV3_Instantiator(ModelInstantiator):\n",
    "    def __init__(self, num_classes: int):\n",
    "        super().__init__()\n",
    "        self.num_classes = num_classes\n",
    "        \n",
    "    def create_model_randomly_initialized(self) -> L.LightningModule:\n",
    "        # Create a DeepLabV3 model with random initialization\n",
    "        model = DeepLabV3(num_classes=self.num_classes)\n",
    "        return model\n",
    "    \n",
    "    def create_model_and_load_backbone(self, backbone_checkpoint_path):\n",
    "        # Does nothing, just create a DeepLabV3 model with random initialization\n",
    "        return self.create_model_randomly_initialized()\n",
    "    \n",
    "    def load_model_from_checkpoint(self, checkpoint_path: PathLike) -> L.LightningModule:\n",
    "        # Load whole DeepLabV3 model from a checkpoint \n",
    "        model = DeepLabV3(num_classes=self.num_classes)\n",
    "        model = FromPretrained(model, ckpt_path=checkpoint_path, strict=False)\n",
    "        return model\n",
    "    \n",
    "\n",
    "# Ok, now we can create a instance of the `DeepLabV3_Instantiator` class.\n",
    "instantiator = DeepLabV3_Instantiator(num_classes=6)\n",
    "print(instantiator)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Creating the ModelConfig\n",
    "\n",
    "Once we have the `ModelInstantiator`, we can create a `ModelConfig` instance. This instance will encapsulate the model creation logic and metadata, and will be passed to the `Experiment` class to create the model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ModelInformation(name='deeplabv3-crossentropy-adam', backbone_name='resnet50', task_type='semantic_segmentation', input_shape=None, output_shape=None, num_classes=6, return_logits=None)\n"
     ]
    }
   ],
   "source": [
    "information = ModelInformation(\n",
    "    name=\"deeplabv3-crossentropy-adam\", # Name of the model (required)\n",
    "    backbone_name=\"resnet50\",           # Backbone name (optional)\n",
    "    task_type=\"semantic_segmentation\",  # Task type (optional)\n",
    "    num_classes=6\n",
    ")\n",
    "\n",
    "print(information)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "ModelConfig\n",
      "├── Instantiator: DeepLabV3_Instantiator\n",
      "├── name: deeplabv3-crossentropy-adam\n",
      "├── backbone_name: resnet50\n",
      "├── task_type: semantic_segmentation\n",
      "├── input_shape: None\n",
      "├── output_shape: None\n",
      "├── num_classes: 6\n",
      "└── return_logits: None\n"
     ]
    }
   ],
   "source": [
    "model_config = ModelConfig(\n",
    "    instantiator=instantiator,          # Model instantiator (required)\n",
    "    information=information,            # Model information (required)\n",
    ")\n",
    "print(model_config)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3. Experiment Definition\n",
    "\n",
    "Once data module and model configuration are set up, we can define the `Experiment` class. The experiment will be named as `f3_deeplabv3_experiment`, and will use the `ModelConfig` instance created in the previous step.\n",
    "\n",
    "We also use the following parameters:\n",
    "- `max_epochs`: Set to 10 for quick testing.\n",
    "- `root_log_dir`: Set to `./logs` to store the experiment logs.\n",
    "- `execution_id`: Set to `0` for the first execution.\n",
    "- `checkpoint_metrics`: no custom checkpoint metrics are defined, as we will not use them in this example.\n",
    "- `evaluation_metrics`: we calculate the mean Intersection over Union (mIoU) metric for the evaluation.\n",
    "- `accelerator`: Set to `gpu` to use GPU acceleration (used to create Lightning trainer).\n",
    "- `devices`: Set to `1` to use one GPU (used to create Lightning trainer).\n",
    "- `seed`: Set to `42` for reproducibility.\n",
    "- `save_predictions`: Set to `True` to save predictions for this example.\n",
    "- `add_last_checkpoint`: Set to `True` to add the last checkpoint to the list of checkpoints.\n",
    "- `save_results`: Set to `True` to save the results of the experiment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "================================================================================\n",
      "                          🚀 Experiment: f3_deeplabv3 🚀\n",
      "================================================================================\n",
      "\n",
      "🛠 Execution Details\n",
      "   ├── Execution ID: 0\n",
      "   ├── Log Dir: /workspaces/minerva-workspace/Minerva-Dev/docs/notebooks/logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0\n",
      "   ├── Seed: 42\n",
      "   ├── Accelerator: gpu\n",
      "   ├── Devices: 1\n",
      "   ├── Max Epochs: 10\n",
      "   ├── Train Batches: all\n",
      "   ├── Val Batches: all\n",
      "   └── Test Batches: all\n",
      "\n",
      "🧠 Model Information\n",
      "   ├── Model Name: deeplabv3-crossentropy-adam\n",
      "   ├── Pretrained Backbone: FROM SCRATCH\n",
      "   ├── Input Shape: None\n",
      "   ├── Output Shape: None\n",
      "   └── Num Classes: 6\n",
      "\n",
      "📂 Dataset Information\n",
      "      ==================================================\n",
      "                          🆔 F3_Dataset\n",
      "      ==================================================\n",
      "      └── Predict Split: test\n",
      "      📂 Datasets:\n",
      "         ├── Train Dataset:\n",
      "         │      ==================================================\n",
      "         │                 📂 SimpleDataset Information            \n",
      "         │      ==================================================\n",
      "         │      📌 Dataset Type: SimpleDataset\n",
      "         │         └── Reader 0: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=float64)\n",
      "         │         │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "         │         └── Reader 1: NumpyArrayReader(samples=401, shape=(1, 701, 255), dtype=uint8)\n",
      "         │         │     └── Transform: None\n",
      "         │         │\n",
      "         │         └── Total Readers: 2\n",
      "         │      ==================================================\n",
      "         ├── Val Dataset:\n",
      "         │      None\n",
      "         └── Test Dataset:\n",
      "                ==================================================\n",
      "                           📂 SimpleDataset Information            \n",
      "                ==================================================\n",
      "                📌 Dataset Type: SimpleDataset\n",
      "                   └── Reader 0: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=float64)\n",
      "                   │     └── Transform: Repeat(axis=0, n_repetitions=3)\n",
      "                   └── Reader 1: NumpyArrayReader(samples=200, shape=(1, 701, 255), dtype=uint8)\n",
      "                   │     └── Transform: Squeeze(axis=0)\n",
      "                   │\n",
      "                   └── Total Readers: 2\n",
      "                ==================================================\n",
      "\n",
      "      🛠 **Dataloader Configurations:**\n",
      "         ├── Dataloader class: <class 'torch.utils.data.dataloader.DataLoader'>\n",
      "         ├── Train Dataloader Kwargs:\n",
      "               ├── batch_size: 16\n",
      "               ├── num_workers: 4\n",
      "               ├── shuffle: true\n",
      "               ├── drop_last: true\n",
      "         ├── Val Dataloader Kwargs:\n",
      "               ├── batch_size: 16\n",
      "               ├── num_workers: 4\n",
      "               ├── shuffle: false\n",
      "               ├── drop_last: false\n",
      "         └── Test Dataloader Kwargs:\n",
      "               ├── batch_size: 16\n",
      "               ├── num_workers: 4\n",
      "               ├── shuffle: false\n",
      "               ├── drop_last: false\n",
      "      ==================================================\n",
      "\n"
     ]
    }
   ],
   "source": [
    "experiment = Experiment(\n",
    "    experiment_name=\"f3_deeplabv3\",  # Name of the experiment (required)\n",
    "    model_config=model_config,       # Model configuration (required)\n",
    "    data_module=data_module,         # Data module (required)\n",
    "    root_log_dir=Path(\"logs\"),  # Root log directory (optional)\n",
    "    execution_id=0,\n",
    "    checkpoint_metrics=None,\n",
    "    accelerator=\"gpu\",  # Accelerator (optional)\n",
    "    devices=1,          # Number of devices (optional)\n",
    "    max_epochs=10,\n",
    "    evaluation_metrics={\"mIoU\": JaccardIndex(num_classes=6, task=\"multiclass\")},\n",
    "    seed=42,\n",
    "    save_predictions=True,\n",
    "    save_results=True,\n",
    "    add_last_checkpoint=True\n",
    ")\n",
    "\n",
    "print(experiment)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4. Training and Evaluate Model\n",
    "\n",
    "Once the `Experiment` class is defined, we can run the experiment using the `run` method. \n",
    "The `run` method is the main entry point for executing the experiment. It handles the entire lifecycle of the experiment, including training, evaluation, and result logging.\n",
    "\n",
    "The `run` method have a `task` parameter that controls the type of task to be performed. It can be:\n",
    "- `fit`: To train the model\n",
    "- `evaluate`: To evaluate the model\n",
    "- `fit-evaluate`: To train and evaluate the model (both steps above, for convenience)\n",
    "\n",
    "for `fit` and `evaluate` tasks a lightning trainer object will be created using the parameters passed to the `Experiment` constructor (accelerator, devices, etc.).\n",
    "\n",
    "In general, the `fit` method will:\n",
    "- Setup directories, logger, and callbacks\n",
    "- Create the model randomly initialized (if `pretrained_backbone_path` is not provided) or create the model and load the backbone (if `pretrained_backbone_path` is provided)\n",
    "- Create the trainer and fit the model using `trainer.fit()` method\n",
    "- Save the model checkpoints and logs\n",
    "- Save the metrics to a CSV file\n",
    "\n",
    "The `evaluate` method will:\n",
    "- Setup directories and evaluation metrics\n",
    "- Create the model using the `load_model_from_checkpoint` method\n",
    "- Create the trainer and perform predictions using `trainer.predict()` method\n",
    "- Save the predictions to a file\n",
    "- Evaluate the model using the evaluation metrics, based on the predictions made\n",
    "- Save the results to a file\n",
    "\n",
    "> **NOTE**: If multiple `checkpoint_metrics` are defined, the `evaluate` method will be called for each checkpoint. The results will be saved in separate files, one for each checkpoint. You may control this behaviour by passing `ckpts_to_evaluate` parameter to the `experiment.run()` method,specifying only the checkpoint to be evaluated. By default, all checkpoints will be evaluated.\n",
    "\n",
    "We going to use the `fit-evaluate` task for this example, so we will train and evaluate the model in one step. The result is a dictionary with the following keys, one for each checkpoint:\n",
    "\n",
    "```python\n",
    "{\n",
    "    \"predictions_path\": predictions_file,   # Path to the predictions file\n",
    "    \"results_path\": results_filename,       # Path to the results file\n",
    "    \"results_path_per_sample\": results_filename_per_sample, # Path to the per sample results file\n",
    "    \"results\": results,                 # Pandas dataframe with the results for each metric\n",
    "    \"results_per_sample\": per_sample_results, # Pandas dataframe with the results for each sample\n",
    "}\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "** Seed set to: 42 **\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "GPU available: True (cuda), used: True\n",
      "TPU available: False, using: 0 TPU cores\n",
      "HPU available: False, using: 0 HPUs\n",
      "/home/vscode/.local/lib/python3.10/site-packages/lightning/pytorch/trainer/configuration_validator.py:70: You defined a `validation_step` but have no `val_dataloader`. Skipping val loop.\n",
      "LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "================================================================================\n",
      "                           Experiment: f3_deeplabv3                             \n",
      "================================================================================\n",
      "🧠 Model\n",
      "   ├── Name: deeplabv3-crossentropy-adam\n",
      "   ├── Finetune: No\n",
      "   ├── Resumed From: Beginning\n",
      "   ├── Expected Input Shape: None\n",
      "   ├── Expected Output Shape: None\n",
      "   ├── Total Params: 41,684,014\n",
      "   └── Trainable Params: 41,684,014 (100.00%)\n",
      "\n",
      "📊 Dataset\n",
      "   ├── Train Samples: 401\n",
      "   |   ├── Input Shape: shape=(3, 701, 255)\n",
      "   |   └── Label Shape: shape=(1, 701, 255)\n",
      "   └── Validation Dataset: None\n",
      "\n",
      "💾 Logging & Checkpoints\n",
      "   ├── Log Dir: /workspaces/minerva-workspace/Minerva-Dev/docs/notebooks/logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0\n",
      "   ├── Metrics Path: logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/metrics.csv\n",
      "   └── Checkpoints Dir: logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/checkpoints\n",
      "       └── Files: last.ckpt\n",
      "\n",
      "⚙️ Trainer Config\n",
      "   ├── Max Epochs: 10\n",
      "   ├── Train Batches: None\n",
      "   ├── Accelerator: gpu\n",
      "   ├── Strategy: auto\n",
      "   ├── Devices: 1\n",
      "   ├── Num Nodes: 1\n",
      "   └── Seed: 42\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "  | Name     | Type                    | Params | Mode \n",
      "-------------------------------------------------------------\n",
      "0 | backbone | DeepLabV3Backbone       | 25.6 M | train\n",
      "1 | fc       | DeepLabV3PredictionHead | 16.1 M | train\n",
      "2 | loss_fn  | CrossEntropyLoss        | 0      | train\n",
      "-------------------------------------------------------------\n",
      "41.7 M    Trainable params\n",
      "0         Non-trainable params\n",
      "41.7 M    Total params\n",
      "166.736   Total estimated model params size (MB)\n",
      "186       Modules in train mode\n",
      "0         Modules in eval mode\n",
      "/home/vscode/.local/lib/python3.10/site-packages/lightning/pytorch/loops/fit_loop.py:310: The number of training batches (25) is smaller than the logging interval Trainer(log_every_n_steps=50). Set a lower value for log_every_n_steps if you want to see logs for the training epoch.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 9: 100%|██████████| 25/25 [00:11<00:00,  2.09it/s, v_num=0, train_loss=0.0285]"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "`Trainer.fit` stopped: `max_epochs=10` reached.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 9: 100%|██████████| 25/25 [00:21<00:00,  1.16it/s, v_num=0, train_loss=0.0285]\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "GPU available: True (cuda), used: True\n",
      "TPU available: False, using: 0 TPU cores\n",
      "HPU available: False, using: 0 HPUs\n",
      "LOCAL_RANK: 0 - CUDA_VISIBLE_DEVICES: [0]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Model loaded from logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/checkpoints/last.ckpt\n",
      "\n",
      "================================================================================\n",
      "                     Evaluation: f3_deeplabv3 (last.ckpt)                       \n",
      "================================================================================\n",
      "💾 Checkpoint\n",
      "   ├── Checkpoint Path: logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/checkpoints/last.ckpt\n",
      "   └── Predictions Path: logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/predictions/last.npy\n",
      "\n",
      "📊 Dataset\n",
      "   ├── Predict Samples: 200\n",
      "   ├── Input: shape=(3, 701, 255)\n",
      "   └── Label: shape=(701, 255)\n",
      "\n",
      "📈 Evaluation Metrics\n",
      "   ├── mIoU: MulticlassJaccardIndex\n",
      "\n",
      "⚙️ Trainer Config\n",
      "   ├── Max Epochs: 10\n",
      "   ├── Predict Batches: None\n",
      "   ├── Accelerator: gpu\n",
      "   ├── Strategy: auto\n",
      "   ├── Devices: 1\n",
      "   ├── Num Nodes: 1\n",
      "   └── Seed: 42\n",
      "Predicting DataLoader 0: 100%|██████████| 13/13 [00:04<00:00,  3.18it/s]\n",
      "Predictions saved to logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/predictions/last.npy\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Computing metrics: 100%|██████████| 13/13 [00:00<00:00, 13.14it/s]\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Results saved to logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/results/last.csv\n",
      "No per-sample evaluation metrics provided. Skipping per-sample evaluation.\n",
      "Checkpoint last evaluated!\n",
      "Result: ['last']\n"
     ]
    }
   ],
   "source": [
    "result = experiment.run(task=\"fit-evaluate\")\n",
    "print(f\"Result: {list(result.keys())}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can get the results from the last checkpoint by using the `results` key. The results is a pandas dataframe with one column for each metric and one row for each sample."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>sample</th>\n",
       "      <th>mIoU</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>all</td>\n",
       "      <td>0.691551</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  sample      mIoU\n",
       "0    all  0.691551"
      ]
     },
     "execution_count": 29,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ckpt_name = \"last\"\n",
    "result[ckpt_name][\"results\"]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 5. Managing Results and Lifecycle\n",
    "\n",
    "Once the experiment is completed, we can use the `Experiment` class to manage the results and lifecycle of the experiment.\n",
    "\n",
    "The following methods and properties are available:\n",
    "- `checkpoint_paths` (property): Returns the paths to the model checkpoints saved during training. This is a dictionary with the checkpoint name as key and the path as value.\n",
    "- `training_metrics_path` (property): Returns the path to the training metrics CSV file.\n",
    "- `training_metrics` (property): Returns the training metrics as a Pandas dataframe.\n",
    "- `prediction_paths` (property): Returns the paths to the predictions files saved during evaluation, one for each checkpoint. This is a dictionary with the checkpoint name as key and the path as value.\n",
    "- `load_predictions_of_ckpt` (method): Loads the predictions for a specific checkpoint. It expects the checkpoint name as argument. Names can be achieved using the `checkpoint_paths` property.\n",
    "- `results_paths` (property): Returns the paths to the results files saved during evaluation, one for each checkpoint. This is a dictionary with the checkpoint name as key and the path as value.\n",
    "- `load_results_of_ckpt` (method): Loads the results for a specific checkpoint. It expects the checkpoint name as argument. Names can be achieved using the `results_paths` property.\n",
    "- `status` (property): Returns information and status of the experiment in a dictionary format. The `state` key indicates whether the experiment is: \"evaluated\", \"predicted\", \"executed\", or \"not executed\". The \"not executed\" means the experiment was not run yet. The \"executed\" means the experiment was run, but not evaluated yet. The \"predicted\" means the experiment was run and predictions were made, but not evaluated yet. The \"evaluated\" means the experiment was run and evaluated. This state is based on the files saved in the experiment directory. Thus, if you opt to not save predictions or results, the status will be \"executed\" even if the experiment was run and evaluated once.\n",
    "- `cleanup` (method): Cleans up the experiment directory, removing all files and subdirectories."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'experiment_name': 'f3_deeplabv3',\n",
       " 'log_dir': PosixPath('/workspaces/minerva-workspace/Minerva-Dev/docs/notebooks/logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0'),\n",
       " 'checkpoints': {'last': PosixPath('logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/checkpoints/last.ckpt')},\n",
       " 'training_metrics': PosixPath('logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/metrics.csv'),\n",
       " 'prediction_paths': {'last': PosixPath('logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/predictions/last.npy')},\n",
       " 'results_paths': {'last': PosixPath('logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0/results/last.csv')},\n",
       " 'state': 'evaluated'}"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# We can check the experiment state using status funtion\n",
    "\n",
    "experiment.status"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can print the directory structure of the experiment directory to see the files and subdirectories created during the experiment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "logs\n",
      "└── f3_deeplabv3\n",
      "    └── F3_Dataset\n",
      "        └── deeplabv3-crossentropy-adam\n",
      "            └── 0\n",
      "                ├── checkpoints\n",
      "                │   └── last.ckpt\n",
      "                ├── predictions\n",
      "                │   └── last.npy\n",
      "                ├── results\n",
      "                │   └── last.csv\n",
      "                └── metrics.csv\n"
     ]
    }
   ],
   "source": [
    "def print_tree(root: Path, prefix: str = \"\"):\n",
    "    if not root.is_dir():\n",
    "        print(f\"{root} is not a directory.\")\n",
    "        return\n",
    "\n",
    "    entries = sorted(root.iterdir(), key=lambda x: (x.is_file(), x.name.lower()))\n",
    "    for i, entry in enumerate(entries):\n",
    "        connector = \"└── \" if i == len(entries) - 1 else \"├── \"\n",
    "        print(prefix + connector + entry.name)\n",
    "        if entry.is_dir():\n",
    "            extension = \"    \" if i == len(entries) - 1 else \"│   \"\n",
    "            print_tree(entry, prefix + extension)\n",
    "\n",
    "\n",
    "print(experiment.root_log_dir)\n",
    "print_tree(experiment.root_log_dir)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can check the evaluated metrics from a specific checkpoint using the `load_results_of_ckpt` method.It is equivalent from the results returned by the `run` method (using `fit-evaluate` task)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>sample</th>\n",
       "      <th>mIoU</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>all</td>\n",
       "      <td>0.691551</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  sample      mIoU\n",
       "0    all  0.691551"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results = experiment.load_results_of_ckpt(\"last\")\n",
    "results"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can check the training metrics using the `training_metrics` property. It returns a pandas dataframe with the training metrics for each epoch, based on lightning CSV Logger."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>epoch</th>\n",
       "      <th>step</th>\n",
       "      <th>train_loss</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>0</td>\n",
       "      <td>24</td>\n",
       "      <td>0.331632</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1</td>\n",
       "      <td>49</td>\n",
       "      <td>0.085685</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2</td>\n",
       "      <td>74</td>\n",
       "      <td>0.060906</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>3</td>\n",
       "      <td>99</td>\n",
       "      <td>0.051845</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>4</td>\n",
       "      <td>124</td>\n",
       "      <td>0.049144</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>5</td>\n",
       "      <td>149</td>\n",
       "      <td>0.041069</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>6</td>\n",
       "      <td>174</td>\n",
       "      <td>0.036828</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>7</td>\n",
       "      <td>199</td>\n",
       "      <td>0.034012</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>8</td>\n",
       "      <td>224</td>\n",
       "      <td>0.030449</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>9</td>\n",
       "      <td>249</td>\n",
       "      <td>0.028480</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   epoch  step  train_loss\n",
       "0      0    24    0.331632\n",
       "1      1    49    0.085685\n",
       "2      2    74    0.060906\n",
       "3      3    99    0.051845\n",
       "4      4   124    0.049144\n",
       "5      5   149    0.041069\n",
       "6      6   174    0.036828\n",
       "7      7   199    0.034012\n",
       "8      8   224    0.030449\n",
       "9      9   249    0.028480"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "training_metrics = experiment.training_metrics\n",
    "training_metrics"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can plot the training metrics using matplotlib or any other plotting library. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA1cAAAHACAYAAABOPpIiAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABOIElEQVR4nO39eXxU9d3//z/PzGRmsq+QBSIBSdzYFyMg0atGQK0LakW/tgi9bvXXurQ22lb8FFxQcaXcFAtXbW21rRVbxct6VdSmImARFMSlIoQ9LFkh+z4zvz8mGRgImJBJzszkcb/dzo2Zc84cXiPR8uz7/X69DY/H4xEAAAAAoEcsZhcAAAAAAOGAcAUAAAAAAUC4AgAAAIAAIFwBAAAAQAAQrgAAAAAgAAhXAAAAABAAhCsAAAAACADCFQAAAAAEgM3sAoKR2+3WwYMHFRsbK8MwzC4HAAAAgEk8Ho9qa2uVkZEhi+XUY1OEq04cPHhQmZmZZpcBAAAAIEgUFxdr8ODBp7yHcNWJ2NhYSd5/gHFxcSZXAwAAAMAsNTU1yszM9GWEUyFcdaJjKmBcXBzhCgAAAECXlgvR0AIAAAAAAoBwBQAAAAABQLgCAAAAgABgzRUAAADQTR6PR21tbXK5XGaXgh6yWq2y2WwB2YKJcAUAAAB0Q0tLiw4dOqSGhgazS0GAREVFKT09XXa7vUfPIVwBAAAAXeR2u7V7925ZrVZlZGTIbrcHZMQD5vB4PGppaVF5ebl2796t7Ozsb9wo+FQIVwAAAEAXtbS0yO12KzMzU1FRUWaXgwCIjIxURESE9u7dq5aWFjmdztN+Fg0tAAAAgG7qyegGgk+g/jz5qQAAAACAACBcAQAAAEAAEK4AAAAAdFtWVpaWLFlidhlBhXAFAAAAhDHDME55PPDAA6f13I8//li33nprj2q7+OKLddddd/XoGcGEboEhwO32yGKhxScAAAC679ChQ77XK1as0IIFC7Rt2zbfuZiYGN9rj8cjl8slm+2bY8KAAQMCW2gYYOQqiHk8HhW8ukXjH35PeyvrzS4HAAAAnfB4PGpoaevzw+PxdKm+tLQ03xEfHy/DMHzvv/76a8XGxurtt9/W+PHj5XA4tG7dOu3cuVNXX321UlNTFRMTo4kTJ+qf//yn33OPnxZoGIZ++9vfaubMmYqKilJ2drbefPPNHv2zfe2113TeeefJ4XAoKytLTz/9tN/1X//618rOzpbT6VRqaqquv/5637W//e1vGjlypCIjI5WcnKz8/HzV1/fu36kZuQpihmFo/5FGHWlo1ZqiCn0vOdrskgAAAHCcxlaXzl3wTp//vl89NF1R9sD8df7ee+/VU089pWHDhikxMVHFxcW6/PLL9cgjj8jhcOill17SlVdeqW3btumMM8446XMefPBBPfHEE3ryySf17LPP6uabb9bevXuVlJTU7Zo2bdqkG264QQ888IBmzZqlf//737rtttuUnJysOXPm6JNPPtGPf/xj/fGPf9TkyZN1+PBhrV27VpJ3tO6mm27SE088oZkzZ6q2tlZr167tciA9XYSrIHdRzgBt3H1Ya7eX63sXDDG7HAAAAIShhx56SJdeeqnvfVJSkkaPHu17v3DhQq1cuVJvvvmm7rjjjpM+Z86cObrpppskSY8++qieeeYZbdy4UTNmzOh2TYsXL9Yll1yi+fPnS5JycnL01Vdf6cknn9ScOXO0b98+RUdH69vf/rZiY2M1ZMgQjR07VpI3XLW1tenaa6/VkCHev0OPHDmy2zV0F+EqyE3NTtGT72zTv3dWqtXlVoSVmZwAAADBJDLCqq8emm7K7xsoEyZM8HtfV1enBx54QP/3f//nCyqNjY3at2/fKZ8zatQo3+vo6GjFxcWprKzstGraunWrrr76ar9zU6ZM0ZIlS+RyuXTppZdqyJAhGjZsmGbMmKEZM2b4piSOHj1al1xyiUaOHKnp06dr2rRpuv7665WYmHhatXQVf1MPciMy4pUYFaG65jZ9uq/K7HIAAABwHMMwFGW39flhGIFreBYd7b/85J577tHKlSv16KOPau3atdqyZYtGjhyplpaWUz4nIiLihH82brc7YHUeKzY2Vps3b9Zf/vIXpaena8GCBRo9erSqqqpktVr13nvv6e2339a5556rZ599VmeddZZ2797dK7V0IFwFOYvF0IXZ3k4sa4vKTa4GAAAA/cGHH36oOXPmaObMmRo5cqTS0tK0Z8+ePq3hnHPO0YcffnhCXTk5ObJavaN2NptN+fn5euKJJ/T5559rz549+te//iXJG+ymTJmiBx98UJ9++qnsdrtWrlzZqzUzLTAE5GWn6O+fHdSa7eW6e9pZZpcDAACAMJedna3XX39dV155pQzD0Pz583ttBKq8vFxb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",
      "text/plain": [
       "<Figure size 1000x500 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.figure(figsize=(10, 5))\n",
    "plt.plot(training_metrics[\"epoch\"], training_metrics[\"train_loss\"], label=\"Train Loss\")\n",
    "plt.xlabel(\"Epoch\")\n",
    "plt.ylabel(\"Train Loss\")\n",
    "plt.legend()\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If saved, we can also obtain the predictions using the `load_predictions_of_ckpt` method. It return the logits predictions for the specific checkpoint. The predictions are saved in a numpy array format, with (N, L, H, W) shape, where N is the number of samples, L is the number of classes (logits), H is the height and W is the width of the image. \n",
    "\n",
    "Let's compare the predictions with the ground truth labels using matplotlib. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(701, 255)"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "index = 100\n",
    "\n",
    "# Get the test data and labels\n",
    "test_labels = experiment.data_module.test_dataset[index][1]\n",
    "test_labels.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(701, 255)"
      ]
     },
     "execution_count": 40,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "predictions = experiment.load_predictions_of_ckpt(\"last\")\n",
    "# Calculcate the predictions from logits\n",
    "predictions = predictions[index].argmax(axis=0)\n",
    "predictions.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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2VlwDPF4nD179uSP4YknniCRSHDZZZflt9m3bx+GYfDkk0+u+j7nDA4OAlBbWwvAs88+SzabLTiWXbt20dHRUXAs559/Pk1NTfltrrvuOoaGhnjllVdWce99rutyzz33MDo6yt69eyvyGG699VZuuOGGgn2Gyvt7HDhwgA0bNrBlyxZuvPFGjh8/XnHH8b3vfY/LLruMf/Wv/hWNjY1cfPHF/O3f/m3+/kr8vGcyGf7xH/+RD33oQyilKurvUSpSm0pXm9ZCXQKpTeVyLFKXyvezXsraVFFh6ezZs7iuW3DQAE1NTXR2dpZorxYmt5+zHUNnZyeNjY0F91uWRW1tbcmO0/M8br/9dq644gp2794N+PsZCARIJBIF2049lmLHmrtvtbz00ktUV1cTDAb5+Mc/zr333su5555bUccAcM899/Dcc89x5513Truvko5lz5493H333dx3333cddddHDlyhCuvvJLh4eGKOo7Dhw9z1113sX37dn70ox/xiU98gt/+7d/m7//+7wv2pZI+79/5zncYGBjg5ptvzu9fpfw9SkVqU2neq5Vel0BqUzkdi9Sl8v2sQ2lrk7X43Rbrya233srLL7/MY489VupdWZSdO3fywgsvMDg4yD/90z9x00038cgjj5R6txbkxIkTfOpTn+L+++8nFAqVeneW5F3velf+/y+44AL27NnDxo0b+T//5/8QDodLuGcL43kel112GV/+8pcBuPjii3n55Zf5+te/zk033VTivVucv/u7v+Nd73oXGzZsKPWuCDGrSq9LILWpnEhdKm+lrE0V1bJUX1+PaZrTZrro6uqiubm5RHu1MLn9nO0Ympub6e7uLrjfcRz6+vpKcpy33XYb3//+93n44Ydpa2vL397c3Ewmk2FgYKBg+6nHUuxYc/etlkAgwLZt27j00ku58847ufDCC/nLv/zLijqGZ599lu7ubi655BIsy8KyLB555BG++tWvYlkWTU1NFXMsUyUSCXbs2MHBgwcr6m/S0tLCueeeW3DbOeeck++6UWmf92PHjvHAAw/wW7/1W/nbKunvUSpSm1b/vboW6hJIbSq3Y5lM6lJ5fNah9LWposJSIBDg0ksv5cEHH8zf5nkeDz74IHv37i3hns3f5s2baW5uLjiGoaEhnnzyyfwx7N27l4GBAZ599tn8Ng899BCe57Fnz55V21etNbfddhv33nsvDz30EJs3by64/9JLL8W27YJj2b9/P8ePHy84lpdeeqngQ3f//fcTi8WmfZhXk+d5pNPpijqGa665hpdeeokXXngh/3PZZZdx44035v+/Uo5lqpGREQ4dOkRLS0tF/U2uuOKKadMWv/HGG2zcuBGorM87wDe+8Q0aGxu54YYb8rdV0t+jVKQ2rd57dS3XJZDaVOpjmUzqUnnUJSiD2rRcM1SslnvuuUcHg0F9991361dffVV/9KMf1YlEomCmi1IbHh7Wzz//vH7++ec1oP/8z/9cP//88/rYsWNaa3/KxkQiob/73e/qF198Uf/Kr/xK0SkbL774Yv3kk0/qxx57TG/fvn3Vp2z8xCc+oePxuP7JT35SMHXj2NhYfpuPf/zjuqOjQz/00EP6mWee0Xv37tV79+7N35+btvHaa6/VL7zwgr7vvvt0Q0PDqk6l+dnPflY/8sgj+siRI/rFF1/Un/3sZ7VSSv/4xz+umGOYyeQZh7SunGP5zGc+o3/yk5/oI0eO6Mcff1zv27dP19fX6+7u7oo6jqeeekpblqX/43/8j/rAgQP6m9/8po5EIvof//Ef89tUyufddV3d0dGhf//3f3/afZXy9yglqU2rY63UJa2lNpXbsUhdKq/Pek451KaKC0taa/1Xf/VXuqOjQwcCAX355Zfrn//856XepQIPP/ywBqb93HTTTVprf9rGP/iDP9BNTU06GAzqa665Ru/fv7/gOXp7e/Vv/uZv6urqah2LxfQtt9yih4eHV/U4ih0DoL/xjW/kt0kmk/rf/bt/p2tqanQkEtG/9mu/ps+cOVPwPEePHtXvete7dDgc1vX19fozn/mMzmazq3YcH/rQh/TGjRt1IBDQDQ0N+pprrskXo0o5hplMLUiVcizvf//7dUtLiw4EArq1tVW///3vL1gDolKOQ2ut/9//+3969+7dOhgM6l27dum/+Zu/Kbi/Uj7vP/rRjzQwbd+0rqy/RylJbVp5a6UuaS21qdyORepSeX3Wc8qhNimttZ5/O5QQQgghhBBCrA8VNWZJCCGEEEIIIVaLhCUhhBBCCCGEKELCkhBCCCGEEEIUIWFJCCGEEEIIIYqQsCSEEEIIIYQQRUhYEkIIIYQQQogiJCwJIYQQQgghRBESloQQQgghhBCiCAlLQgghhBBCCFGEhCUhhBBCCCGEKELCkhBCCCGEEEIUIWFJCCGEEEIIIYr4/wH/qX1zeZH1ogAAAABJRU5ErkJggg==",
      "text/plain": [
       "<Figure size 1000x500 with 2 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# Lets visualize the test data, labels and predictions\n",
    "\n",
    "fig, axes = plt.subplots(1, 2, figsize=(10, 5))\n",
    "axes[0].imshow(predictions.T)\n",
    "axes[0].set_title(\"Predicted\")\n",
    "axes[1].imshow(test_labels.T)\n",
    "axes[1].set_title(\"True\")\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 6. Cleanup\n",
    "\n",
    "Finally, we can clean up the experiment directory using the `cleanup` method. This will remove all files and subdirectories created during the experiment. This is useful to free up disk space and remove unnecessary files."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Experiment at '/workspaces/minerva-workspace/Minerva-Dev/docs/notebooks/logs/f3_deeplabv3/F3_Dataset/deeplabv3-crossentropy-adam/0' cleaned up.\n"
     ]
    }
   ],
   "source": [
    "experiment.cleanup()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can print the directory structure of the experiment directory to check if files were removed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "logs\n",
      "└── f3_deeplabv3\n",
      "    └── F3_Dataset\n",
      "        └── deeplabv3-crossentropy-adam\n"
     ]
    }
   ],
   "source": [
    "print(experiment.root_log_dir)\n",
    "print_tree(experiment.root_log_dir)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
