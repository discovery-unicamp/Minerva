

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>minerva.models.nets &mdash; minerva  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="minerva.models.nets.base" href="base/index.html" />
    <link rel="prev" title="minerva.models.loaders" href="../loaders/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            minerva
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../design.html">Minerva Design</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Examples and Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contributing.html">Contributing to Minerva</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../../api.html">Programming Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html">minerva</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../index.html#submodules">Submodules</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../../analysis/index.html">minerva.analysis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../data/index.html">minerva.data</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../losses/index.html">minerva.losses</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../index.html">minerva.models</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../optimizers/index.html">minerva.optimizers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../pipelines/index.html">minerva.pipelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../samplers/index.html">minerva.samplers</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../transforms/index.html">minerva.transforms</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../utils/index.html">minerva.utils</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">minerva</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../../api.html">Programming Reference</a></li>
          <li class="breadcrumb-item"><a href="../../index.html">minerva</a></li>
          <li class="breadcrumb-item"><a href="../index.html">minerva.models</a></li>
      <li class="breadcrumb-item active">minerva.models.nets</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/autoapi/minerva/models/nets/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-minerva.models.nets">
<span id="minerva-models-nets"></span><h1>minerva.models.nets<a class="headerlink" href="#module-minerva.models.nets" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="base/index.html">minerva.models.nets.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="classic_ml_pipeline/index.html">minerva.models.nets.classic_ml_pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="conv_autoencoders_encoders/index.html">minerva.models.nets.conv_autoencoders_encoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpc_networks/index.html">minerva.models.nets.cpc_networks</a></li>
<li class="toctree-l1"><a class="reference internal" href="dcnn/index.html">minerva.models.nets.dcnn</a></li>
<li class="toctree-l1"><a class="reference internal" href="mlp/index.html">minerva.models.nets.mlp</a></li>
<li class="toctree-l1"><a class="reference internal" href="siamese_network_wrapper/index.html">minerva.models.nets.siamese_network_wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="tfc/index.html">minerva.models.nets.tfc</a></li>
<li class="toctree-l1"><a class="reference internal" href="tnc/index.html">minerva.models.nets.tnc</a></li>
</ul>
</div>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading"></a></h2>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#minerva.models.nets.DeepLabV3" title="minerva.models.nets.DeepLabV3"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeepLabV3</span></code></a></p></td>
<td><p>A DeeplabV3 with a ResNet50 backbone</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#minerva.models.nets.MLP" title="minerva.models.nets.MLP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MLP</span></code></a></p></td>
<td><p>A flexible multilayer perceptron (MLP) implemented as a subclass of nn.Sequential.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#minerva.models.nets.SETR_PUP" title="minerva.models.nets.SETR_PUP"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SETR_PUP</span></code></a></p></td>
<td><p>SET-R model with PUP head for image segmentation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#minerva.models.nets.SimpleSupervisedModel" title="minerva.models.nets.SimpleSupervisedModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SimpleSupervisedModel</span></code></a></p></td>
<td><p>A modular Lightning model wrapper for supervised learning tasks.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#minerva.models.nets.UNet" title="minerva.models.nets.UNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UNet</span></code></a></p></td>
<td><p>This class is a simple implementation of the U-Net model, which is a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#minerva.models.nets.WiseNet" title="minerva.models.nets.WiseNet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WiseNet</span></code></a></p></td>
<td><p>A modular Lightning model wrapper for supervised learning tasks.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="package-contents">
<h2>Package Contents<a class="headerlink" href="#package-contents" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.DeepLabV3">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">DeepLabV3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backbone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred_head</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.optim.Adam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_scheduler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_scheduler_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/deeplabv3.html#DeepLabV3"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.DeepLabV3" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#minerva.models.nets.base.SimpleSupervisedModel" title="minerva.models.nets.base.SimpleSupervisedModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minerva.models.nets.base.SimpleSupervisedModel</span></code></a></p>
<p>A DeeplabV3 with a ResNet50 backbone</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Link to this heading"></a></h3>
<p>Liang-Chieh Chen, George Papandreou, Florian Schroff, Hartwig Adam.
“Rethinking Atrous Convolution for Semantic Image Segmentation”, 2017</p>
<p>Initializes a DeepLabV3 model.</p>
</section>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>backbone: Optional[nn.Module]</dt><dd><p>The backbone network. Defaults to None, which will use a ResNet50
backbone.</p>
</dd>
<dt>pred_head: Optional[nn.Module]</dt><dd><p>The prediction head network. Defaults to None, which will use a
DeepLabV3PredictionHead with specified number of classes.</p>
</dd>
<dt>loss_fn: Optional[nn.Module]</dt><dd><p>The loss function. Defaults to None, which will use a
CrossEntropyLoss.</p>
</dd>
<dt>learning_rate: float</dt><dd><p>The learning rate for the optimizer. Defaults to 0.001.</p>
</dd>
<dt>num_classes: int</dt><dd><p>The number of classes for prediction. Defaults to 6.</p>
</dd>
<dt>train_metrics: Optional[Dict[str, Metric]]</dt><dd><p>The metrics to be computed during training. Defaults to None.</p>
</dd>
<dt>val_metrics: Optional[Dict[str, Metric]]</dt><dd><p>The metrics to be computed during validation. Defaults to None.</p>
</dd>
<dt>test_metrics: Optional[Dict[str, Metric]]</dt><dd><p>The metrics to be computed during testing. Defaults to None.</p>
</dd>
<dt>optimizer: type</dt><dd><p>Optimizer class to be instantiated. By default, it is set to
<cite>torch.optim.Adam</cite>. Should be a subclass of
<cite>torch.optim.Optimizer</cite> (e.g., <cite>torch.optim.SGD</cite>).</p>
</dd>
<dt>optimizer_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the optimizer constructor.</p>
</dd>
<dt>lr_scheduler<span class="classifier">type, optional</span></dt><dd><p>Learning rate scheduler class to be instantiated. By default, it is
set to None, which means no scheduler will be used. Should be a
subclass of <cite>torch.optim.lr_scheduler.LRScheduler</cite> (e.g.,
<cite>torch.optim.lr_scheduler.StepLR</cite>).</p>
</dd>
<dt>lr_scheduler_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the scheduler constructor.</p>
</dd>
<dt>output_shape: Optional[Tuple[int, …]]</dt><dd><p>The output shape of the model. If None, the output shape will be
the same as the input shape. Defaults to None. This is useful for
models that require a specific output shape, that is different from
the input shape.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.DeepLabV3._loss_func">
<span class="sig-name descname"><span class="pre">_loss_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/deeplabv3.html#DeepLabV3._loss_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.DeepLabV3._loss_func" title="Link to this definition"></a></dt>
<dd><p>Calculate the loss between the output and the input data.</p>
<section id="id1">
<h4>Parameters<a class="headerlink" href="#id1" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>y_hat<span class="classifier">torch.Tensor</span></dt><dd><p>The output data from the forward pass.</p>
</dd>
<dt>y<span class="classifier">torch.Tensor</span></dt><dd><p>The input data/label.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_hat</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.DeepLabV3.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/deeplabv3.html#DeepLabV3.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.DeepLabV3.forward" title="Link to this definition"></a></dt>
<dd><p>Perform a forward pass with the input data on the backbone model.</p>
<section id="id2">
<h4>Parameters<a class="headerlink" href="#id2" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">torch.Tensor</span></dt><dd><p>The input data.</p>
</dd>
</dl>
</section>
<section id="id3">
<h4>Returns<a class="headerlink" href="#id3" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The output data from the forward pass.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.DeepLabV3.output_shape">
<span class="sig-name descname"><span class="pre">output_shape</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.DeepLabV3.output_shape" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>backbone</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>pred_head</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>loss_fn</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>)</p></li>
<li><p><strong>num_classes</strong> (<em>int</em>)</p></li>
<li><p><strong>train_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>val_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>test_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>optimizer</strong> (<em>type</em>)</p></li>
<li><p><strong>optimizer_kwargs</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>lr_scheduler</strong> (<em>Optional</em><em>[</em><em>type</em><em>]</em>)</p></li>
<li><p><strong>lr_scheduler_kwargs</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>output_shape</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>Ellipsis</em><em>]</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.MLP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">MLP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation_cls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nn.ReLU</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intermediate_ops</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_op</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/mlp.html#MLP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.MLP" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">torch.nn.Sequential</span></code></p>
<p>A flexible multilayer perceptron (MLP) implemented as a subclass of nn.Sequential.</p>
<p>This class allows you to quickly build an MLP with:
- Custom layer sizes
- Configurable activation functions
- Optional intermediate operations (e.g., BatchNorm, Dropout) after each linear layer
- An optional final operation (e.g., normalization, final activation)</p>
<section id="id4">
<h3>Parameters<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>layer_sizes<span class="classifier">Sequence[int]</span></dt><dd><p>A list of integers specifying the sizes of each layer. Must contain at least two values:
the input and output dimensions.</p>
</dd>
<dt>activation_cls<span class="classifier">type, optional</span></dt><dd><p>The activation function class (must inherit from nn.Module) to use between layers.
Defaults to nn.ReLU.</p>
</dd>
<dt>intermediate_ops<span class="classifier">Optional[List[Optional[nn.Module]]], optional</span></dt><dd><p>A list of modules (e.g., nn.BatchNorm1d, nn.Dropout) to apply after each linear layer
and before the activation. Each item corresponds to one linear layer. Use <cite>None</cite> to skip
an operation for that layer. Must be the same length as the number of linear layers.</p>
</dd>
<dt>final_op<span class="classifier">Optional[nn.Module], optional</span></dt><dd><p>A module to apply after the last layer (e.g., a final activation or normalization).</p>
</dd>
<dt><a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs :</dt><dd><p>Additional arguments passed to the activation function constructor.</p>
</dd>
</dl>
</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="Link to this heading"></a></h3>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">nn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlp</span> <span class="o">=</span> <span class="n">MLP</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">activation_cls</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">intermediate_ops</span><span class="o">=</span><span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm1d</span><span class="p">(</span><span class="mi">256</span><span class="p">),</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm1d</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="kc">None</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">final_op</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">Sigmoid</span><span class="p">()</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mlp</span><span class="p">)</span>
<span class="go">MLP(</span>
<span class="go">    (0): Linear(in_features=128, out_features=256, bias=True)</span>
<span class="go">    (1): BatchNorm1d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span>
<span class="go">    (2): ReLU()</span>
<span class="go">    (3): Linear(in_features=256, out_features=64, bias=True)</span>
<span class="go">    (4): BatchNorm1d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</span>
<span class="go">    (5): ReLU()</span>
<span class="go">    (6): Linear(in_features=64, out_features=10, bias=True)</span>
<span class="go">    (7): Sigmoid()</span>
<span class="go">)</span>
</pre></div>
</div>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>layer_sizes</strong> (<em>Sequence</em><em>[</em><em>int</em><em>]</em>)</p></li>
<li><p><strong>activation_cls</strong> (<em>type</em>)</p></li>
<li><p><strong>intermediate_ops</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>final_op</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">SETR_PUP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">patch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">24</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_heads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mlp_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4096</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoder_dropout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">norm_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decoder_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_convs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">up_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">align_corners</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decoder_dropout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_act</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolate_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bilinear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aux_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aux_output_layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aux_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_backbone_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freeze_backbone_on_load</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">original_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">head_lr_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_engine</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">lightning.pytorch.LightningModule</span></code></p>
<p>SET-R model with PUP head for image segmentation.</p>
<section id="methods">
<h3>Methods<a class="headerlink" href="#methods" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>forward(x: torch.Tensor) -&gt; torch.Tensor</dt><dd><p>Forward pass of the model.</p>
</dd>
<dt>_compute_metrics(y_hat: torch.Tensor, y: torch.Tensor, step_name: str)</dt><dd><p>Compute metrics for the given step.</p>
</dd>
<dt>_loss_func(y_hat: Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]], y: torch.Tensor) -&gt; torch.Tensor</dt><dd><p>Calculate the loss between the output and the input data.</p>
</dd>
<dt>_single_step(batch: torch.Tensor, batch_idx: int, step_name: str)</dt><dd><p>Perform a single step of the training/validation loop.</p>
</dd>
<dt>training_step(batch: torch.Tensor, batch_idx: int)</dt><dd><p>Perform a single training step.</p>
</dd>
<dt>validation_step(batch: torch.Tensor, batch_idx: int)</dt><dd><p>Perform a single validation step.</p>
</dd>
<dt>test_step(batch: torch.Tensor, batch_idx: int)</dt><dd><p>Perform a single test step.</p>
</dd>
<dt>predict_step(batch: torch.Tensor, batch_idx: int, dataloader_idx: Optional[int] = None)</dt><dd><p>Perform a single prediction step.</p>
</dd>
<dt>load_backbone(path: str, freeze: bool = False)</dt><dd><p>Load a pre-trained backbone.</p>
</dd>
<dt>configure_optimizers()</dt><dd><p>Configure the optimizer for the model.</p>
</dd>
<dt>create_from_dict(config: Dict) -&gt; “SETR_PUP”</dt><dd><p>Create an instance of SETR_PUP from a configuration dictionary.</p>
</dd>
</dl>
<p>Initialize the SETR model with Progressive Upsampling Head.</p>
</section>
<section id="id9">
<h3>Parameters<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>image_size<span class="classifier">Union[int, Tuple[int, int]], optional</span></dt><dd><p>Size of the input image, by default 512.</p>
</dd>
<dt>patch_size<span class="classifier">int, optional</span></dt><dd><p>Size of the patches to be extracted from the input image, by
default 16.</p>
</dd>
<dt>num_layers<span class="classifier">int, optional</span></dt><dd><p>Number of transformer layers, by default 24.</p>
</dd>
<dt>num_heads<span class="classifier">int, optional</span></dt><dd><p>Number of attention heads, by default 16.</p>
</dd>
<dt>hidden_dim<span class="classifier">int, optional</span></dt><dd><p>Dimension of the hidden layer, by default 1024.</p>
</dd>
<dt>mlp_dim<span class="classifier">int, optional</span></dt><dd><p>Dimension of the MLP layer, by default 4096.</p>
</dd>
<dt>encoder_dropout<span class="classifier">float, optional</span></dt><dd><p>Dropout rate for the encoder, by default 0.1.</p>
</dd>
<dt>num_classes<span class="classifier">int, optional</span></dt><dd><p>Number of output classes, by default 1000.</p>
</dd>
<dt>norm_layer<span class="classifier">Optional[nn.Module], optional</span></dt><dd><p>Normalization layer, by default None.</p>
</dd>
<dt>decoder_channels<span class="classifier">int, optional</span></dt><dd><p>Number of channels in the decoder, by default 256.</p>
</dd>
<dt>num_convs<span class="classifier">int, optional</span></dt><dd><p>Number of convolutional layers in the decoder, by default 4.</p>
</dd>
<dt>up_scale<span class="classifier">int, optional</span></dt><dd><p>Upscaling factor for the decoder, by default 2.</p>
</dd>
<dt>kernel_size<span class="classifier">int, optional</span></dt><dd><p>Kernel size for the convolutional layers, by default 3.</p>
</dd>
<dt>align_corners<span class="classifier">bool, optional</span></dt><dd><p>Whether to align corners when interpolating, by default False.</p>
</dd>
<dt>decoder_dropout<span class="classifier">float, optional</span></dt><dd><p>Dropout rate for the decoder, by default 0.1.</p>
</dd>
<dt>conv_norm<span class="classifier">Optional[nn.Module], optional</span></dt><dd><p>Normalization layer for the convolutional layers, by default None.</p>
</dd>
<dt>conv_act<span class="classifier">Optional[nn.Module], optional</span></dt><dd><p>Activation function for the convolutional layers, by default None.</p>
</dd>
<dt>interpolate_mode<span class="classifier">str, optional</span></dt><dd><p>Interpolation mode, by default “bilinear”.</p>
</dd>
<dt>loss_fn<span class="classifier">Optional[nn.Module], optional</span></dt><dd><p>Loss function, when None defaults to nn.CrossEntropyLoss, by
default None.</p>
</dd>
<dt>optimizer_type<span class="classifier">Optional[type], optional</span></dt><dd><p>Type of optimizer, by default None.</p>
</dd>
<dt>optimizer_params<span class="classifier">Optional[Dict], optional</span></dt><dd><p>Parameters for the optimizer, by default None.</p>
</dd>
<dt>train_metrics<span class="classifier">Optional[Dict[str, Metric]], optional</span></dt><dd><p>Metrics for training, by default None.</p>
</dd>
<dt>val_metrics<span class="classifier">Optional[Dict[str, Metric]], optional</span></dt><dd><p>Metrics for validation, by default None.</p>
</dd>
<dt>test_metrics<span class="classifier">Optional[Dict[str, Metric]], optional</span></dt><dd><p>Metrics for testing, by default None.</p>
</dd>
<dt>aux_output<span class="classifier">bool, optional</span></dt><dd><p>Whether to use auxiliary outputs, by default True.</p>
</dd>
<dt>aux_output_layers<span class="classifier">list[int], optional</span></dt><dd><p>Layers for auxiliary outputs, when None it defaults to [9, 14, 19].</p>
</dd>
<dt>aux_weights<span class="classifier">list[float], optional</span></dt><dd><p>Weights for auxiliary outputs, when None it defaults [0.3, 0.3, 0.3].</p>
</dd>
<dt>load_backbone_path<span class="classifier">Optional[str], optional</span></dt><dd><p>Path to load the backbone model, by default None.</p>
</dd>
<dt>freeze_backbone_on_load<span class="classifier">bool, optional</span></dt><dd><p>Whether to freeze the backbone model on load, by default True.</p>
</dd>
<dt>learning_rate<span class="classifier">float, optional</span></dt><dd><p>Learning rate, by default 1e-3.</p>
</dd>
<dt>loss_weights<span class="classifier">Optional[list[float]], optional</span></dt><dd><p>Weights for the loss function, by default None.</p>
</dd>
<dt>original_resolution<span class="classifier">Optional[Tuple[int, int]], optional</span></dt><dd><p>The original resolution of the input image in the pre-training
weights. When None, positional embeddings will not be interpolated.
Defaults to None.</p>
</dd>
<dt>head_lr_factor<span class="classifier">float, optional</span></dt><dd><p>Learning rate factor for the head. used if you need different
learning rates for backbone and prediction head, by default 1.0.</p>
</dd>
<dt>test_engine<span class="classifier">Optional[_Engine], optional</span></dt><dd><p>Engine used for test and validation steps. When None, behavior of
all steps, training, testing and validation is the same, by default None.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP._compute_metrics">
<span class="sig-name descname"><span class="pre">_compute_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP._compute_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP._compute_metrics" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_hat</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>step_name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP._loss_func">
<span class="sig-name descname"><span class="pre">_loss_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP._loss_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP._loss_func" title="Link to this definition"></a></dt>
<dd><p>Calculate the loss between the output and the input data.</p>
<section id="id10">
<h4>Parameters<a class="headerlink" href="#id10" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>y_hat<span class="classifier">torch.Tensor</span></dt><dd><p>The output data from the forward pass.</p>
</dd>
<dt>y<span class="classifier">torch.Tensor</span></dt><dd><p>The input data/label.</p>
</dd>
</dl>
</section>
<section id="id11">
<h4>Returns<a class="headerlink" href="#id11" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_hat</strong> (<em>Union</em><em>[</em><em>torch.Tensor</em><em>, </em><em>Tuple</em><em>[</em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP._single_step">
<span class="sig-name descname"><span class="pre">_single_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP._single_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP._single_step" title="Link to this definition"></a></dt>
<dd><p>Perform a single step of the training/validation loop.</p>
<section id="id12">
<h4>Parameters<a class="headerlink" href="#id12" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>batch<span class="classifier">torch.Tensor</span></dt><dd><p>The input data.</p>
</dd>
<dt>batch_idx<span class="classifier">int</span></dt><dd><p>The index of the batch.</p>
</dd>
<dt>step_name<span class="classifier">str</span></dt><dd><p>The name of the step, either “train” or “val”.</p>
</dd>
</dl>
</section>
<section id="id13">
<h4>Returns<a class="headerlink" href="#id13" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
<li><p><strong>step_name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.aux_weights">
<span class="sig-name descname"><span class="pre">aux_weights</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.aux_weights" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.configure_optimizers">
<span class="sig-name descname"><span class="pre">configure_optimizers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.configure_optimizers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.configure_optimizers" title="Link to this definition"></a></dt>
<dd><p>Choose what optimizers and learning-rate schedulers to use in your optimization. Normally you’d need one.
But in the case of GANs or similar you might have multiple. Optimization with multiple optimizers only works in
the manual optimization mode.</p>
<dl class="simple">
<dt>Return:</dt><dd><p>Any of these 6 options.</p>
<ul class="simple">
<li><p><strong>Single optimizer</strong>.</p></li>
<li><p><strong>List or Tuple</strong> of optimizers.</p></li>
<li><p><strong>Two lists</strong> - The first list has multiple optimizers, and the second has multiple LR schedulers
(or multiple <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code>).</p></li>
<li><p><strong>Dictionary</strong>, with an <code class="docutils literal notranslate"><span class="pre">&quot;optimizer&quot;</span></code> key, and (optionally) a <code class="docutils literal notranslate"><span class="pre">&quot;lr_scheduler&quot;</span></code>
key whose value is a single LR scheduler or <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code>.</p></li>
<li><p><strong>None</strong> - Fit will run without any optimizer.</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code> is a dictionary which contains the scheduler and its associated configuration.
The default configuration is shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lr_scheduler_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># REQUIRED: The scheduler instance</span>
    <span class="s2">&quot;scheduler&quot;</span><span class="p">:</span> <span class="n">lr_scheduler</span><span class="p">,</span>
    <span class="c1"># The unit of the scheduler&#39;s step size, could also be &#39;step&#39;.</span>
    <span class="c1"># &#39;epoch&#39; updates the scheduler on epoch end whereas &#39;step&#39;</span>
    <span class="c1"># updates it after a optimizer update.</span>
    <span class="s2">&quot;interval&quot;</span><span class="p">:</span> <span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
    <span class="c1"># How many epochs/steps should pass between calls to</span>
    <span class="c1"># `scheduler.step()`. 1 corresponds to updating the learning</span>
    <span class="c1"># rate after every epoch/step.</span>
    <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1"># Metric to monitor for schedulers like `ReduceLROnPlateau`</span>
    <span class="s2">&quot;monitor&quot;</span><span class="p">:</span> <span class="s2">&quot;val_loss&quot;</span><span class="p">,</span>
    <span class="c1"># If set to `True`, will enforce that the value specified &#39;monitor&#39;</span>
    <span class="c1"># is available when the scheduler is updated, thus stopping</span>
    <span class="c1"># training if not found. If set to `False`, it will only produce a warning</span>
    <span class="s2">&quot;strict&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="c1"># If using the `LearningRateMonitor` callback to monitor the</span>
    <span class="c1"># learning rate progress, this keyword can be used to specify</span>
    <span class="c1"># a custom logged name</span>
    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When there are schedulers in which the <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method is conditioned on a value, such as the
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.optim.lr_scheduler.ReduceLROnPlateau</span></code> scheduler, Lightning requires that the
<code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code> contains the keyword <code class="docutils literal notranslate"><span class="pre">&quot;monitor&quot;</span></code> set to the metric name that the scheduler
should be conditioned on.</p>
<p>Metrics can be made available to monitor by simply logging it using
<code class="docutils literal notranslate"><span class="pre">self.log('metric_to_track',</span> <span class="pre">metric_val)</span></code> in your <code class="xref py py-class docutils literal notranslate"><span class="pre">LightningModule</span></code>.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Some things to know:</p>
<ul class="simple">
<li><p>Lightning calls <code class="docutils literal notranslate"><span class="pre">.backward()</span></code> and <code class="docutils literal notranslate"><span class="pre">.step()</span></code> automatically in case of automatic optimization.</p></li>
<li><p>If a learning rate scheduler is specified in <code class="docutils literal notranslate"><span class="pre">configure_optimizers()</span></code> with key
<code class="docutils literal notranslate"><span class="pre">&quot;interval&quot;</span></code> (default “epoch”) in the scheduler configuration, Lightning will call
the scheduler’s <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method automatically in case of automatic optimization.</p></li>
<li><p>If you use 16-bit precision (<code class="docutils literal notranslate"><span class="pre">precision=16</span></code>), Lightning will automatically handle the optimizer.</p></li>
<li><p>If you use <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.optim.LBFGS</span></code>, Lightning handles the closure function automatically for you.</p></li>
<li><p>If you use multiple optimizers, you will have to switch to ‘manual optimization’ mode and step them
yourself.</p></li>
<li><p>If you need to control how often the optimizer steps, override the <code class="xref py py-meth docutils literal notranslate"><span class="pre">optimizer_step()</span></code> hook.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.create_from_dict">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_from_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">config</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.create_from_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.create_from_dict" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>config</strong> (<em>Dict</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#minerva.models.nets.SETR_PUP" title="minerva.models.nets.SETR_PUP">SETR_PUP</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.forward" title="Link to this definition"></a></dt>
<dd><p>Same as <code class="xref py py-meth docutils literal notranslate"><span class="pre">torch.nn.Module.forward()</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><p><a href="#id14"><span class="problematic" id="id15">*</span></a>args: Whatever you decide to pass into the forward method.
<a href="#id16"><span class="problematic" id="id17">**</span></a>kwargs: Keyword arguments are also possible.</p>
</dd>
<dt>Return:</dt><dd><p>Your model’s output</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.head_lr_factor">
<span class="sig-name descname"><span class="pre">head_lr_factor</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1.0</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.head_lr_factor" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.learning_rate">
<span class="sig-name descname"><span class="pre">learning_rate</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.001</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.learning_rate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.load_backbone">
<span class="sig-name descname"><span class="pre">load_backbone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freeze</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.load_backbone"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.load_backbone" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<em>str</em>)</p></li>
<li><p><strong>freeze</strong> (<em>bool</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.loss_fn">
<span class="sig-name descname"><span class="pre">loss_fn</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.loss_fn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#minerva.models.nets.SETR_PUP.metrics" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.model">
<span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#minerva.models.nets.SETR_PUP.model" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.num_classes">
<span class="sig-name descname"><span class="pre">num_classes</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1000</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.num_classes" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.optimizer_type">
<span class="sig-name descname"><span class="pre">optimizer_type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.optimizer_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.predict_step">
<span class="sig-name descname"><span class="pre">predict_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataloader_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.predict_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.predict_step" title="Link to this definition"></a></dt>
<dd><p>Step function called during <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code>. By default, it calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code>. Override to add any processing logic.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_step()</span></code> is used
to scale inference on multi-devices.</p>
<p>To prevent an OOM error, it is possible to use <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code>
callback to write the predictions to disk or database after each batch or on epoch end.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code> should be used while using a spawn
based accelerator. This happens for <code class="docutils literal notranslate"><span class="pre">Trainer(strategy=&quot;ddp_spawn&quot;)</span></code>
or training on 8 TPU cores with <code class="docutils literal notranslate"><span class="pre">Trainer(accelerator=&quot;tpu&quot;,</span> <span class="pre">devices=8)</span></code> as predictions won’t be returned.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>Predicted output (optional).</p>
</dd>
</dl>
<p>Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">LightningModule</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

<span class="n">dm</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">()</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">accelerator</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span> <span class="n">devices</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
<li><p><strong>dataloader_idx</strong> (<em>Optional</em><em>[</em><em>int</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.test_engine">
<span class="sig-name descname"><span class="pre">test_engine</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SETR_PUP.test_engine" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.test_step">
<span class="sig-name descname"><span class="pre">test_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.test_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.test_step" title="Link to this definition"></a></dt>
<dd><p>Operates on a single batch of data from the test set. In this step you’d normally generate examples or
calculate anything of interest such as accuracy.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary. Can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - Skip to the next batch.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># if you have one test dataloader:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span> <span class="o">...</span>


<span class="c1"># if you have multiple test dataloaders:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 1: A single test dataset</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>

    <span class="c1"># implement your own</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># log 6 example images</span>
    <span class="c1"># or generated text... or whatever</span>
    <span class="n">sample_imgs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">sample_imgs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="s1">&#39;example_images&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># calculate acc</span>
    <span class="n">labels_hat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">test_acc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels_hat</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># log the outputs!</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">({</span><span class="s1">&#39;test_loss&#39;</span><span class="p">:</span> <span class="n">loss</span><span class="p">,</span> <span class="s1">&#39;test_acc&#39;</span><span class="p">:</span> <span class="n">test_acc</span><span class="p">})</span>
</pre></div>
</div>
<p>If you pass in multiple test dataloaders, <a class="reference internal" href="#minerva.models.nets.SETR_PUP.test_step" title="minerva.models.nets.SETR_PUP.test_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_step()</span></code></a> will have an additional argument. We recommend
setting the default value of 0 so that you can quickly switch between single and multiple dataloaders.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 2: multiple test dataloaders</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># dataloader_idx tells you which dataset this is.</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>If you don’t need to test you don’t need to implement this method.</p>
</dd>
<dt>Note:</dt><dd><p>When the <a class="reference internal" href="#minerva.models.nets.SETR_PUP.test_step" title="minerva.models.nets.SETR_PUP.test_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_step()</span></code></a> is called, the model has been put in eval mode and
PyTorch gradients have been disabled. At the end of the test epoch, the model goes back
to training mode and gradients are enabled.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.training_step">
<span class="sig-name descname"><span class="pre">training_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.training_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.training_step" title="Link to this definition"></a></dt>
<dd><p>Here you compute and return the training loss and some additional metrics for e.g. the progress bar or
logger.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary which can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code> in the case of
automatic optimization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - In automatic optimization, this will skip to the next batch (but is not supported for
multi-GPU, TPU, or DeepSpeed). For manual optimization, this has no special meaning, as returning
the loss is not required.</p></li>
</ul>
</dd>
</dl>
<p>In this step you’d normally do the forward pass and calculate the loss for a batch.
You can also do fancier things like multiple forward passes or something model specific.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">batch</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</div>
<p>To use multiple optimizers, you can switch to ‘manual optimization’ and control their stepping:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">automatic_optimization</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># Multiple optimizers (e.g.: GANs)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">opt1</span><span class="p">,</span> <span class="n">opt2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">()</span>

    <span class="c1"># do training_step with encoder</span>
    <span class="o">...</span>
    <span class="n">opt1</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
    <span class="c1"># do training_step with decoder</span>
    <span class="o">...</span>
    <span class="n">opt2</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">accumulate_grad_batches</span></code> &gt; 1, the loss returned here will be automatically
normalized by <code class="docutils literal notranslate"><span class="pre">accumulate_grad_batches</span></code> internally.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SETR_PUP.validation_step">
<span class="sig-name descname"><span class="pre">validation_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/setr.html#SETR_PUP.validation_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SETR_PUP.validation_step" title="Link to this definition"></a></dt>
<dd><p>Operates on a single batch of data from the validation set. In this step you’d might generate examples or
calculate anything of interest like accuracy.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary. Can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - Skip to the next batch.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># if you have one val dataloader:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span> <span class="o">...</span>


<span class="c1"># if you have multiple val dataloaders:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 1: A single validation dataset</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>

    <span class="c1"># implement your own</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># log 6 example images</span>
    <span class="c1"># or generated text... or whatever</span>
    <span class="n">sample_imgs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">sample_imgs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="s1">&#39;example_images&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># calculate acc</span>
    <span class="n">labels_hat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">val_acc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels_hat</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># log the outputs!</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">({</span><span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="n">loss</span><span class="p">,</span> <span class="s1">&#39;val_acc&#39;</span><span class="p">:</span> <span class="n">val_acc</span><span class="p">})</span>
</pre></div>
</div>
<p>If you pass in multiple val dataloaders, <a class="reference internal" href="#minerva.models.nets.SETR_PUP.validation_step" title="minerva.models.nets.SETR_PUP.validation_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">validation_step()</span></code></a> will have an additional argument. We recommend
setting the default value of 0 so that you can quickly switch between single and multiple dataloaders.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 2: multiple validation dataloaders</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># dataloader_idx tells you which dataset this is.</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>If you don’t need to validate you don’t need to implement this method.</p>
</dd>
<dt>Note:</dt><dd><p>When the <a class="reference internal" href="#minerva.models.nets.SETR_PUP.validation_step" title="minerva.models.nets.SETR_PUP.validation_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">validation_step()</span></code></a> is called, the model has been put in eval mode
and PyTorch gradients have been disabled. At the end of validation,
the model goes back to training mode and gradients are enabled.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image_size</strong> (<em>Union</em><em>[</em><em>int</em><em>, </em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>patch_size</strong> (<em>int</em>)</p></li>
<li><p><strong>num_layers</strong> (<em>int</em>)</p></li>
<li><p><strong>num_heads</strong> (<em>int</em>)</p></li>
<li><p><strong>hidden_dim</strong> (<em>int</em>)</p></li>
<li><p><strong>mlp_dim</strong> (<em>int</em>)</p></li>
<li><p><strong>encoder_dropout</strong> (<em>float</em>)</p></li>
<li><p><strong>num_classes</strong> (<em>int</em>)</p></li>
<li><p><strong>norm_layer</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>decoder_channels</strong> (<em>int</em>)</p></li>
<li><p><strong>num_convs</strong> (<em>int</em>)</p></li>
<li><p><strong>up_scale</strong> (<em>int</em>)</p></li>
<li><p><strong>kernel_size</strong> (<em>int</em>)</p></li>
<li><p><strong>align_corners</strong> (<em>bool</em>)</p></li>
<li><p><strong>decoder_dropout</strong> (<em>float</em>)</p></li>
<li><p><strong>conv_norm</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>conv_act</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>interpolate_mode</strong> (<em>str</em>)</p></li>
<li><p><strong>loss_fn</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
<li><p><strong>optimizer_type</strong> (<em>Optional</em><em>[</em><em>type</em><em>]</em>)</p></li>
<li><p><strong>optimizer_params</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>]</em>)</p></li>
<li><p><strong>train_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>val_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>test_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>aux_output</strong> (<em>bool</em>)</p></li>
<li><p><strong>aux_output_layers</strong> (<em>Optional</em><em>[</em><em>list</em><em>[</em><em>int</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>aux_weights</strong> (<em>Optional</em><em>[</em><em>list</em><em>[</em><em>float</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>load_backbone_path</strong> (<em>Optional</em><em>[</em><em>str</em><em>]</em>)</p></li>
<li><p><strong>freeze_backbone_on_load</strong> (<em>bool</em>)</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>)</p></li>
<li><p><strong>loss_weights</strong> (<em>Optional</em><em>[</em><em>list</em><em>[</em><em>float</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>original_resolution</strong> (<em>Optional</em><em>[</em><em>Tuple</em><em>[</em><em>int</em><em>, </em><em>int</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>head_lr_factor</strong> (<em>float</em>)</p></li>
<li><p><strong>test_engine</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="../../engines/engine/index.html#minerva.engines.engine._Engine" title="minerva.engines.engine._Engine"><em>minerva.engines.engine._Engine</em></a><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">SimpleSupervisedModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backbone</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">adapter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flatten</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_metrics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">freeze_backbone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">torch.optim.Adam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_scheduler</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lr_scheduler_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">lightning.LightningModule</span></code></p>
<p>A modular Lightning model wrapper for supervised learning tasks.</p>
<p>This class enables the construction of supervised models by combining a
backbone (feature extractor), an optional adapter, and a fully connected
(FC) head. It provides a clean interface for setting up custom training,
validation, and testing pipelines with pluggable loss functions, metrics,
optimizers, and learning rate schedulers.</p>
<p>The architecture is structured as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Backbone Model</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
<p>v</p>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Adapter (Optional)</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
</div></blockquote>
<dl class="simple">
<dt>(Flatten if needed)</dt><dd><p>v</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Fully Connected Head</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
<p>v</p>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Loss Function</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Training and validation steps comprise the following steps:</p>
<ol class="arabic simple">
<li><p>Forward pass input through the backbone.</p></li>
<li><p>Pass through adapter (if provided).</p></li>
<li><p>Flatten the output (if <cite>flatten</cite> is True) before the FC head.</p></li>
<li><p>Forward through the FC head.</p></li>
<li><p>Compute loss with respect to targets.</p></li>
<li><p>Backpropagate and update parameters.</p></li>
<li><p>Compute metrics and log them.</p></li>
<li><p>Return loss. <cite>train_loss</cite>, <cite>val_loss</cite>, and <cite>test_loss</cite> are always
logged, along with any additional metrics specified in the
<cite>train_metrics</cite>, <cite>val_metrics</cite>, and <cite>test_metrics</cite> dictionaries.</p></li>
</ol>
<p>This wrapper is especially useful to quickly set up supervised models for
various tasks, such as image classification, object detection, and
segmentation. It is designed to be flexible and extensible, allowing users
to easily swap out components like the backbone, adapter, and FC head as
needed. The model is built with a focus on simplicity and modularity, making
it easy to adapt to different use cases and requirements.
The model is designed to be used with PyTorch Lightning and is compatible
with its training loop.</p>
<p><strong>Note</strong>: For more complex architectures that does not follow the above
structure should not inherit from this class.</p>
<p><strong>Note</strong>: Input batches must be tuples (input_tensor, target_tensor).</p>
<p>Initializes the supervised model with training components and configs.</p>
<section id="id18">
<h3>Parameters<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>backbone<span class="classifier">torch.nn.Module or LoadableModule</span></dt><dd><p>The backbone (feature extractor) model.</p>
</dd>
<dt>fc<span class="classifier">torch.nn.Module or LoadableModule</span></dt><dd><p>The fully connected head. Use nn.Identity() if not required.</p>
</dd>
<dt>loss_fn<span class="classifier">torch.nn.Module</span></dt><dd><p>Loss function to optimize during training.</p>
</dd>
<dt>adapter<span class="classifier">Callable, optional</span></dt><dd><p>Function to transform backbone outputs before feeding into <cite>fc</cite>.</p>
</dd>
<dt>learning_rate<span class="classifier">float, default=1e-3</span></dt><dd><p>Learning rate used for optimization.</p>
</dd>
<dt>flatten<span class="classifier">bool, default=True</span></dt><dd><p>If True, flattens backbone outputs before <cite>fc</cite>.</p>
</dd>
<dt>train_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for training evaluation.</p>
</dd>
<dt>val_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for validation evaluation.</p>
</dd>
<dt>test_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for test evaluation.</p>
</dd>
<dt>freeze_backbone<span class="classifier">bool, default=False</span></dt><dd><p>If True, backbone parameters are frozen during training.</p>
</dd>
<dt>optimizer: type</dt><dd><p>Optimizer class to be instantiated. By default, it is set to
<cite>torch.optim.Adam</cite>. Should be a subclass of
<cite>torch.optim.Optimizer</cite> (e.g., <cite>torch.optim.SGD</cite>).</p>
</dd>
<dt>optimizer_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the optimizer constructor.</p>
</dd>
<dt>lr_scheduler<span class="classifier">type, optional</span></dt><dd><p>Learning rate scheduler class to be instantiated. By default, it is
set to None, which means no scheduler will be used. Should be a
subclass of <cite>torch.optim.lr_scheduler.LRScheduler</cite> (e.g.,
<cite>torch.optim.lr_scheduler.StepLR</cite>).</p>
</dd>
<dt>lr_scheduler_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the scheduler constructor.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel._compute_metrics">
<span class="sig-name descname"><span class="pre">_compute_metrics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel._compute_metrics"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel._compute_metrics" title="Link to this definition"></a></dt>
<dd><p>Calculate the metrics for the given step.</p>
<section id="id19">
<h4>Parameters<a class="headerlink" href="#id19" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>y_hat<span class="classifier">torch.Tensor</span></dt><dd><p>The output data from the forward pass.</p>
</dd>
<dt>y<span class="classifier">torch.Tensor</span></dt><dd><p>The input data/label.</p>
</dd>
<dt>step_name<span class="classifier">str</span></dt><dd><p>Name of the step. It will be used to get the metrics from the
<cite>self.metrics</cite> attribute.</p>
</dd>
</dl>
</section>
<section id="id20">
<h4>Returns<a class="headerlink" href="#id20" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>Dict[str, torch.Tensor]</dt><dd><p>A dictionary with the metrics values.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_hat</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>step_name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Dict[str, torch.Tensor]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel._loss_func">
<span class="sig-name descname"><span class="pre">_loss_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">y_hat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel._loss_func"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel._loss_func" title="Link to this definition"></a></dt>
<dd><p>Calculate the loss between the output and the input data.</p>
<section id="id21">
<h4>Parameters<a class="headerlink" href="#id21" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>y_hat<span class="classifier">torch.Tensor</span></dt><dd><p>The output data from the forward pass.</p>
</dd>
<dt>y<span class="classifier">torch.Tensor</span></dt><dd><p>The input data/label.</p>
</dd>
</dl>
</section>
<section id="id22">
<h4>Returns<a class="headerlink" href="#id22" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>y_hat</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>y</strong> (<em>torch.Tensor</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel._single_step">
<span class="sig-name descname"><span class="pre">_single_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel._single_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel._single_step" title="Link to this definition"></a></dt>
<dd><p>Perform a single train/validation/test step. It consists in making a
forward pass with the input data on the backbone model, computing the
loss between the output and the input data, and logging the loss.</p>
<section id="id23">
<h4>Parameters<a class="headerlink" href="#id23" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>batch<span class="classifier">torch.Tensor</span></dt><dd><p>The input data. It must be a 2-element tuple of tensors, where the
first tensor is the input data and the second tensor is the mask.</p>
</dd>
<dt>batch_idx<span class="classifier">int</span></dt><dd><p>The index of the batch.</p>
</dd>
<dt>step_name<span class="classifier">str</span></dt><dd><p>The name of the step. It will be used to log the loss. The possible
values are: “train”, “val” and “test”. The loss will be logged as
“{step_name}_loss”.</p>
</dd>
</dl>
</section>
<section id="id24">
<h4>Returns<a class="headerlink" href="#id24" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>A tensor with the loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
<li><p><strong>step_name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.adapter">
<span class="sig-name descname"><span class="pre">adapter</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.adapter" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.backbone">
<span class="sig-name descname"><span class="pre">backbone</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.backbone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.configure_optimizers">
<span class="sig-name descname"><span class="pre">configure_optimizers</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.configure_optimizers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.configure_optimizers" title="Link to this definition"></a></dt>
<dd><p>Choose what optimizers and learning-rate schedulers to use in your optimization. Normally you’d need one.
But in the case of GANs or similar you might have multiple. Optimization with multiple optimizers only works in
the manual optimization mode.</p>
<dl class="simple">
<dt>Return:</dt><dd><p>Any of these 6 options.</p>
<ul class="simple">
<li><p><strong>Single optimizer</strong>.</p></li>
<li><p><strong>List or Tuple</strong> of optimizers.</p></li>
<li><p><strong>Two lists</strong> - The first list has multiple optimizers, and the second has multiple LR schedulers
(or multiple <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code>).</p></li>
<li><p><strong>Dictionary</strong>, with an <code class="docutils literal notranslate"><span class="pre">&quot;optimizer&quot;</span></code> key, and (optionally) a <code class="docutils literal notranslate"><span class="pre">&quot;lr_scheduler&quot;</span></code>
key whose value is a single LR scheduler or <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code>.</p></li>
<li><p><strong>None</strong> - Fit will run without any optimizer.</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code> is a dictionary which contains the scheduler and its associated configuration.
The default configuration is shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">lr_scheduler_config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># REQUIRED: The scheduler instance</span>
    <span class="s2">&quot;scheduler&quot;</span><span class="p">:</span> <span class="n">lr_scheduler</span><span class="p">,</span>
    <span class="c1"># The unit of the scheduler&#39;s step size, could also be &#39;step&#39;.</span>
    <span class="c1"># &#39;epoch&#39; updates the scheduler on epoch end whereas &#39;step&#39;</span>
    <span class="c1"># updates it after a optimizer update.</span>
    <span class="s2">&quot;interval&quot;</span><span class="p">:</span> <span class="s2">&quot;epoch&quot;</span><span class="p">,</span>
    <span class="c1"># How many epochs/steps should pass between calls to</span>
    <span class="c1"># `scheduler.step()`. 1 corresponds to updating the learning</span>
    <span class="c1"># rate after every epoch/step.</span>
    <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1"># Metric to monitor for schedulers like `ReduceLROnPlateau`</span>
    <span class="s2">&quot;monitor&quot;</span><span class="p">:</span> <span class="s2">&quot;val_loss&quot;</span><span class="p">,</span>
    <span class="c1"># If set to `True`, will enforce that the value specified &#39;monitor&#39;</span>
    <span class="c1"># is available when the scheduler is updated, thus stopping</span>
    <span class="c1"># training if not found. If set to `False`, it will only produce a warning</span>
    <span class="s2">&quot;strict&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
    <span class="c1"># If using the `LearningRateMonitor` callback to monitor the</span>
    <span class="c1"># learning rate progress, this keyword can be used to specify</span>
    <span class="c1"># a custom logged name</span>
    <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>When there are schedulers in which the <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method is conditioned on a value, such as the
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.optim.lr_scheduler.ReduceLROnPlateau</span></code> scheduler, Lightning requires that the
<code class="docutils literal notranslate"><span class="pre">lr_scheduler_config</span></code> contains the keyword <code class="docutils literal notranslate"><span class="pre">&quot;monitor&quot;</span></code> set to the metric name that the scheduler
should be conditioned on.</p>
<p>Metrics can be made available to monitor by simply logging it using
<code class="docutils literal notranslate"><span class="pre">self.log('metric_to_track',</span> <span class="pre">metric_val)</span></code> in your <code class="xref py py-class docutils literal notranslate"><span class="pre">LightningModule</span></code>.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Some things to know:</p>
<ul class="simple">
<li><p>Lightning calls <code class="docutils literal notranslate"><span class="pre">.backward()</span></code> and <code class="docutils literal notranslate"><span class="pre">.step()</span></code> automatically in case of automatic optimization.</p></li>
<li><p>If a learning rate scheduler is specified in <code class="docutils literal notranslate"><span class="pre">configure_optimizers()</span></code> with key
<code class="docutils literal notranslate"><span class="pre">&quot;interval&quot;</span></code> (default “epoch”) in the scheduler configuration, Lightning will call
the scheduler’s <code class="docutils literal notranslate"><span class="pre">.step()</span></code> method automatically in case of automatic optimization.</p></li>
<li><p>If you use 16-bit precision (<code class="docutils literal notranslate"><span class="pre">precision=16</span></code>), Lightning will automatically handle the optimizer.</p></li>
<li><p>If you use <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.optim.LBFGS</span></code>, Lightning handles the closure function automatically for you.</p></li>
<li><p>If you use multiple optimizers, you will have to switch to ‘manual optimization’ mode and step them
yourself.</p></li>
<li><p>If you need to control how often the optimizer steps, override the <code class="xref py py-meth docutils literal notranslate"><span class="pre">optimizer_step()</span></code> hook.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.fc">
<span class="sig-name descname"><span class="pre">fc</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.fc" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.flatten" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.forward"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.forward" title="Link to this definition"></a></dt>
<dd><p>Perform a forward pass with the input data on the backbone model.</p>
<section id="id25">
<h4>Parameters<a class="headerlink" href="#id25" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>x<span class="classifier">torch.Tensor</span></dt><dd><p>The input data.</p>
</dd>
</dl>
</section>
<section id="id26">
<h4>Returns<a class="headerlink" href="#id26" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>The output data from the forward pass.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>torch.Tensor</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.freeze_backbone">
<span class="sig-name descname"><span class="pre">freeze_backbone</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.freeze_backbone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.learning_rate">
<span class="sig-name descname"><span class="pre">learning_rate</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.001</span></em><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.learning_rate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.loss_fn">
<span class="sig-name descname"><span class="pre">loss_fn</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.loss_fn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.lr_scheduler">
<span class="sig-name descname"><span class="pre">lr_scheduler</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.lr_scheduler" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.lr_scheduler_kwargs">
<span class="sig-name descname"><span class="pre">lr_scheduler_kwargs</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.lr_scheduler_kwargs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.metrics">
<span class="sig-name descname"><span class="pre">metrics</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.metrics" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.optimizer">
<span class="sig-name descname"><span class="pre">optimizer</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.optimizer" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.optimizer_kwargs">
<span class="sig-name descname"><span class="pre">optimizer_kwargs</span></span><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.optimizer_kwargs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.predict_step">
<span class="sig-name descname"><span class="pre">predict_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataloader_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.predict_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.predict_step" title="Link to this definition"></a></dt>
<dd><p>Step function called during <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code>. By default, it calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code>. Override to add any processing logic.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_step()</span></code> is used
to scale inference on multi-devices.</p>
<p>To prevent an OOM error, it is possible to use <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code>
callback to write the predictions to disk or database after each batch or on epoch end.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code> should be used while using a spawn
based accelerator. This happens for <code class="docutils literal notranslate"><span class="pre">Trainer(strategy=&quot;ddp_spawn&quot;)</span></code>
or training on 8 TPU cores with <code class="docutils literal notranslate"><span class="pre">Trainer(accelerator=&quot;tpu&quot;,</span> <span class="pre">devices=8)</span></code> as predictions won’t be returned.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>Predicted output (optional).</p>
</dd>
</dl>
<p>Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">LightningModule</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

<span class="n">dm</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">()</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">accelerator</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span> <span class="n">devices</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.test_step">
<span class="sig-name descname"><span class="pre">test_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.test_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.test_step" title="Link to this definition"></a></dt>
<dd><p>Operates on a single batch of data from the test set. In this step you’d normally generate examples or
calculate anything of interest such as accuracy.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary. Can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - Skip to the next batch.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># if you have one test dataloader:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span> <span class="o">...</span>


<span class="c1"># if you have multiple test dataloaders:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 1: A single test dataset</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>

    <span class="c1"># implement your own</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># log 6 example images</span>
    <span class="c1"># or generated text... or whatever</span>
    <span class="n">sample_imgs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">sample_imgs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="s1">&#39;example_images&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># calculate acc</span>
    <span class="n">labels_hat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">test_acc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels_hat</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># log the outputs!</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">({</span><span class="s1">&#39;test_loss&#39;</span><span class="p">:</span> <span class="n">loss</span><span class="p">,</span> <span class="s1">&#39;test_acc&#39;</span><span class="p">:</span> <span class="n">test_acc</span><span class="p">})</span>
</pre></div>
</div>
<p>If you pass in multiple test dataloaders, <a class="reference internal" href="#minerva.models.nets.SimpleSupervisedModel.test_step" title="minerva.models.nets.SimpleSupervisedModel.test_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_step()</span></code></a> will have an additional argument. We recommend
setting the default value of 0 so that you can quickly switch between single and multiple dataloaders.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 2: multiple test dataloaders</span>
<span class="k">def</span><span class="w"> </span><span class="nf">test_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># dataloader_idx tells you which dataset this is.</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>If you don’t need to test you don’t need to implement this method.</p>
</dd>
<dt>Note:</dt><dd><p>When the <a class="reference internal" href="#minerva.models.nets.SimpleSupervisedModel.test_step" title="minerva.models.nets.SimpleSupervisedModel.test_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">test_step()</span></code></a> is called, the model has been put in eval mode and
PyTorch gradients have been disabled. At the end of the test epoch, the model goes back
to training mode and gradients are enabled.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.training_step">
<span class="sig-name descname"><span class="pre">training_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.training_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.training_step" title="Link to this definition"></a></dt>
<dd><p>Here you compute and return the training loss and some additional metrics for e.g. the progress bar or
logger.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary which can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code> in the case of
automatic optimization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - In automatic optimization, this will skip to the next batch (but is not supported for
multi-GPU, TPU, or DeepSpeed). For manual optimization, this has no special meaning, as returning
the loss is not required.</p></li>
</ul>
</dd>
</dl>
<p>In this step you’d normally do the forward pass and calculate the loss for a batch.
You can also do fancier things like multiple forward passes or something model specific.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">batch</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span>
</pre></div>
</div>
<p>To use multiple optimizers, you can switch to ‘manual optimization’ and control their stepping:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">automatic_optimization</span> <span class="o">=</span> <span class="kc">False</span>


<span class="c1"># Multiple optimizers (e.g.: GANs)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">training_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">opt1</span><span class="p">,</span> <span class="n">opt2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimizers</span><span class="p">()</span>

    <span class="c1"># do training_step with encoder</span>
    <span class="o">...</span>
    <span class="n">opt1</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
    <span class="c1"># do training_step with decoder</span>
    <span class="o">...</span>
    <span class="n">opt2</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">accumulate_grad_batches</span></code> &gt; 1, the loss returned here will be automatically
normalized by <code class="docutils literal notranslate"><span class="pre">accumulate_grad_batches</span></code> internally.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.SimpleSupervisedModel.validation_step">
<span class="sig-name descname"><span class="pre">validation_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/base.html#SimpleSupervisedModel.validation_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.SimpleSupervisedModel.validation_step" title="Link to this definition"></a></dt>
<dd><p>Operates on a single batch of data from the validation set. In this step you’d might generate examples or
calculate anything of interest like accuracy.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code> - The loss tensor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dict</span></code> - A dictionary. Can include any keys, but must include the key <code class="docutils literal notranslate"><span class="pre">'loss'</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> - Skip to the next batch.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># if you have one val dataloader:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span> <span class="o">...</span>


<span class="c1"># if you have multiple val dataloaders:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 1: A single validation dataset</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">batch</span>

    <span class="c1"># implement your own</span>
    <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="c1"># log 6 example images</span>
    <span class="c1"># or generated text... or whatever</span>
    <span class="n">sample_imgs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">torchvision</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">make_grid</span><span class="p">(</span><span class="n">sample_imgs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">experiment</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="s1">&#39;example_images&#39;</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># calculate acc</span>
    <span class="n">labels_hat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">val_acc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">labels_hat</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># log the outputs!</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log_dict</span><span class="p">({</span><span class="s1">&#39;val_loss&#39;</span><span class="p">:</span> <span class="n">loss</span><span class="p">,</span> <span class="s1">&#39;val_acc&#39;</span><span class="p">:</span> <span class="n">val_acc</span><span class="p">})</span>
</pre></div>
</div>
<p>If you pass in multiple val dataloaders, <a class="reference internal" href="#minerva.models.nets.SimpleSupervisedModel.validation_step" title="minerva.models.nets.SimpleSupervisedModel.validation_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">validation_step()</span></code></a> will have an additional argument. We recommend
setting the default value of 0 so that you can quickly switch between single and multiple dataloaders.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CASE 2: multiple validation dataloaders</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validation_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># dataloader_idx tells you which dataset this is.</span>
    <span class="o">...</span>
</pre></div>
</div>
<dl class="simple">
<dt>Note:</dt><dd><p>If you don’t need to validate you don’t need to implement this method.</p>
</dd>
<dt>Note:</dt><dd><p>When the <a class="reference internal" href="#minerva.models.nets.SimpleSupervisedModel.validation_step" title="minerva.models.nets.SimpleSupervisedModel.validation_step"><code class="xref py py-meth docutils literal notranslate"><span class="pre">validation_step()</span></code></a> is called, the model has been put in eval mode
and PyTorch gradients have been disabled. At the end of validation,
the model goes back to training mode and gradients are enabled.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>backbone</strong> (<em>Union</em><em>[</em><em>torch.nn.Module</em><em>, </em><a class="reference internal" href="../loaders/index.html#minerva.models.loaders.LoadableModule" title="minerva.models.loaders.LoadableModule"><em>minerva.models.loaders.LoadableModule</em></a><em>]</em>)</p></li>
<li><p><strong>fc</strong> (<em>Union</em><em>[</em><em>torch.nn.Module</em><em>, </em><a class="reference internal" href="../loaders/index.html#minerva.models.loaders.LoadableModule" title="minerva.models.loaders.LoadableModule"><em>minerva.models.loaders.LoadableModule</em></a><em>]</em>)</p></li>
<li><p><strong>loss_fn</strong> (<em>torch.nn.Module</em>)</p></li>
<li><p><strong>adapter</strong> (<em>Optional</em><em>[</em><em>Callable</em><em>[</em><em>[</em><em>torch.Tensor</em><em>]</em><em>, </em><em>torch.Tensor</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>)</p></li>
<li><p><strong>flatten</strong> (<em>bool</em>)</p></li>
<li><p><strong>train_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>val_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>test_metrics</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>torchmetrics.Metric</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>freeze_backbone</strong> (<em>bool</em>)</p></li>
<li><p><strong>optimizer</strong> (<em>type</em>)</p></li>
<li><p><strong>optimizer_kwargs</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>lr_scheduler</strong> (<em>Optional</em><em>[</em><em>type</em><em>]</em>)</p></li>
<li><p><strong>lr_scheduler_kwargs</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.UNet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">UNet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bilinear</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/unet.html#UNet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.UNet" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#minerva.models.nets.base.SimpleSupervisedModel" title="minerva.models.nets.base.SimpleSupervisedModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minerva.models.nets.base.SimpleSupervisedModel</span></code></a></p>
<p>This class is a simple implementation of the U-Net model, which is a
convolutional neural network used for image segmentation. The model consists
of a contracting path (encoder) and an expansive path (decoder). The
contracting path follows the typical architecture of a convolutional neural
network, with repeated applications of convolutions and max pooling layers.
The expansive path consists of up-convolutions and concatenation of feature
maps from the contracting path. The model also has skip connections, which
allows the expansive path to use information from the contracting path at
multiple resolutions. The U-Net model was originally proposed by
Ronneberger, Fischer, and Brox in 2015.</p>
<p>This architecture, handles arbitrary input sizes, and returns an output of
the same size as the input. The expected input size is (N, C, H, W), where N
is the batch size, C is the number of channels, H is the height of the input
image, and W is the width of the input image.</p>
<p>Note that, for this implementation, the input batch is a single tensor and
not a tuple of tensors (e.g., data and label).</p>
<p>Note that this class wrappers the <cite>_UNet</cite> class, which is the actual
implementation of the U-Net model, into a <cite>SimpleReconstructionNet</cite> class,
which is a simple autoencoder pipeline for reconstruction tasks.</p>
<section id="id27">
<h3>References<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<p>Ronneberger, Olaf, Philipp Fischer, and Thomas Brox. “U-net: Convolutional
networks for biomedical image segmentation.” Medical Image Computing and
Computer-Assisted Intervention-MICCAI 2015: 18th International Conference,
Munich, Germany, October 5-9, 2015, Proceedings, Part III 18. Springer
International Publishing, 2015.</p>
<p>Wrapper implementation of the U-Net model.</p>
</section>
<section id="id28">
<h3>Parameters<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>n_channels<span class="classifier">int, optional</span></dt><dd><p>The number of channels of the input, by default 1</p>
</dd>
<dt>bilinear<span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite> use bilinear interpolation for upsampling, by default
False.</p>
</dd>
<dt>learning_rate<span class="classifier">float, optional</span></dt><dd><p>The learning rate to Adam optimizer, by default 1e-3</p>
</dd>
<dt>loss_fn<span class="classifier">torch.nn.Module, optional</span></dt><dd><p>The function used to compute the loss. If <cite>None</cite>, it will be used
the MSELoss, by default None.</p>
</dd>
<dt>kwargs<span class="classifier">Dict</span></dt><dd><p>Additional arguments to be passed to the <cite>SimpleSupervisedModel</cite>
class.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_channels</strong> (<em>int</em>)</p></li>
<li><p><strong>bilinear</strong> (<em>bool</em>)</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>)</p></li>
<li><p><strong>loss_fn</strong> (<em>Optional</em><em>[</em><em>torch.nn.Module</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="minerva.models.nets.WiseNet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">minerva.models.nets.</span></span><span class="sig-name descname"><span class="pre">WiseNet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">in_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/wisenet.html#WiseNet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.WiseNet" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="base/index.html#minerva.models.nets.base.SimpleSupervisedModel" title="minerva.models.nets.base.SimpleSupervisedModel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">minerva.models.nets.base.SimpleSupervisedModel</span></code></a></p>
<p>A modular Lightning model wrapper for supervised learning tasks.</p>
<p>This class enables the construction of supervised models by combining a
backbone (feature extractor), an optional adapter, and a fully connected
(FC) head. It provides a clean interface for setting up custom training,
validation, and testing pipelines with pluggable loss functions, metrics,
optimizers, and learning rate schedulers.</p>
<p>The architecture is structured as follows:</p>
<blockquote>
<div><table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Backbone Model</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
<p>v</p>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Adapter (Optional)</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
</div></blockquote>
<dl class="simple">
<dt>(Flatten if needed)</dt><dd><p>v</p>
</dd>
</dl>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Fully Connected Head</p></td>
</tr>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
</div>
<p>v</p>
</div></blockquote>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>Loss Function</p></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>Training and validation steps comprise the following steps:</p>
<ol class="arabic simple">
<li><p>Forward pass input through the backbone.</p></li>
<li><p>Pass through adapter (if provided).</p></li>
<li><p>Flatten the output (if <cite>flatten</cite> is True) before the FC head.</p></li>
<li><p>Forward through the FC head.</p></li>
<li><p>Compute loss with respect to targets.</p></li>
<li><p>Backpropagate and update parameters.</p></li>
<li><p>Compute metrics and log them.</p></li>
<li><p>Return loss. <cite>train_loss</cite>, <cite>val_loss</cite>, and <cite>test_loss</cite> are always
logged, along with any additional metrics specified in the
<cite>train_metrics</cite>, <cite>val_metrics</cite>, and <cite>test_metrics</cite> dictionaries.</p></li>
</ol>
<p>This wrapper is especially useful to quickly set up supervised models for
various tasks, such as image classification, object detection, and
segmentation. It is designed to be flexible and extensible, allowing users
to easily swap out components like the backbone, adapter, and FC head as
needed. The model is built with a focus on simplicity and modularity, making
it easy to adapt to different use cases and requirements.
The model is designed to be used with PyTorch Lightning and is compatible
with its training loop.</p>
<p><strong>Note</strong>: For more complex architectures that does not follow the above
structure should not inherit from this class.</p>
<p><strong>Note</strong>: Input batches must be tuples (input_tensor, target_tensor).</p>
<p>Initializes the supervised model with training components and configs.</p>
<section id="id29">
<h3>Parameters<a class="headerlink" href="#id29" title="Link to this heading"></a></h3>
<dl class="simple">
<dt>backbone<span class="classifier">torch.nn.Module or LoadableModule</span></dt><dd><p>The backbone (feature extractor) model.</p>
</dd>
<dt>fc<span class="classifier">torch.nn.Module or LoadableModule</span></dt><dd><p>The fully connected head. Use nn.Identity() if not required.</p>
</dd>
<dt>loss_fn<span class="classifier">torch.nn.Module</span></dt><dd><p>Loss function to optimize during training.</p>
</dd>
<dt>adapter<span class="classifier">Callable, optional</span></dt><dd><p>Function to transform backbone outputs before feeding into <cite>fc</cite>.</p>
</dd>
<dt>learning_rate<span class="classifier">float, default=1e-3</span></dt><dd><p>Learning rate used for optimization.</p>
</dd>
<dt>flatten<span class="classifier">bool, default=True</span></dt><dd><p>If True, flattens backbone outputs before <cite>fc</cite>.</p>
</dd>
<dt>train_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for training evaluation.</p>
</dd>
<dt>val_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for validation evaluation.</p>
</dd>
<dt>test_metrics<span class="classifier">dict, optional</span></dt><dd><p>TorchMetrics dictionary for test evaluation.</p>
</dd>
<dt>freeze_backbone<span class="classifier">bool, default=False</span></dt><dd><p>If True, backbone parameters are frozen during training.</p>
</dd>
<dt>optimizer: type</dt><dd><p>Optimizer class to be instantiated. By default, it is set to
<cite>torch.optim.Adam</cite>. Should be a subclass of
<cite>torch.optim.Optimizer</cite> (e.g., <cite>torch.optim.SGD</cite>).</p>
</dd>
<dt>optimizer_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the optimizer constructor.</p>
</dd>
<dt>lr_scheduler<span class="classifier">type, optional</span></dt><dd><p>Learning rate scheduler class to be instantiated. By default, it is
set to None, which means no scheduler will be used. Should be a
subclass of <cite>torch.optim.lr_scheduler.LRScheduler</cite> (e.g.,
<cite>torch.optim.lr_scheduler.StepLR</cite>).</p>
</dd>
<dt>lr_scheduler_kwargs<span class="classifier">dict, optional</span></dt><dd><p>Additional kwargs passed to the scheduler constructor.</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.WiseNet._single_step">
<span class="sig-name descname"><span class="pre">_single_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_name</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/wisenet.html#WiseNet._single_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.WiseNet._single_step" title="Link to this definition"></a></dt>
<dd><p>Perform a single train/validation/test step. It consists in making a
forward pass with the input data on the backbone model, computing the
loss between the output and the input data, and logging the loss.</p>
<section id="id30">
<h4>Parameters<a class="headerlink" href="#id30" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>batch<span class="classifier">torch.Tensor</span></dt><dd><p>The input data. It must be a 2-element tuple of tensors, where the
first tensor is the input data and the second tensor is the mask.</p>
</dd>
<dt>batch_idx<span class="classifier">int</span></dt><dd><p>The index of the batch.</p>
</dd>
<dt>step_name<span class="classifier">str</span></dt><dd><p>The name of the step. It will be used to log the loss. The possible
values are: “train”, “val” and “test”. The loss will be logged as
“{step_name}_loss”.</p>
</dd>
</dl>
</section>
<section id="id31">
<h4>Returns<a class="headerlink" href="#id31" title="Link to this heading"></a></h4>
<dl class="simple">
<dt>torch.Tensor</dt><dd><p>A tensor with the loss value.</p>
</dd>
</dl>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>batch</strong> (<em>torch.Tensor</em>)</p></li>
<li><p><strong>batch_idx</strong> (<em>int</em>)</p></li>
<li><p><strong>step_name</strong> (<em>str</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="minerva.models.nets.WiseNet.predict_step">
<span class="sig-name descname"><span class="pre">predict_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataloader_idx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../../_modules/minerva/models/nets/image/wisenet.html#WiseNet.predict_step"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#minerva.models.nets.WiseNet.predict_step" title="Link to this definition"></a></dt>
<dd><p>Step function called during <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code>. By default, it calls
<code class="xref py py-meth docutils literal notranslate"><span class="pre">forward()</span></code>. Override to add any processing logic.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">predict_step()</span></code> is used
to scale inference on multi-devices.</p>
<p>To prevent an OOM error, it is possible to use <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code>
callback to write the predictions to disk or database after each batch or on epoch end.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">BasePredictionWriter</span></code> should be used while using a spawn
based accelerator. This happens for <code class="docutils literal notranslate"><span class="pre">Trainer(strategy=&quot;ddp_spawn&quot;)</span></code>
or training on 8 TPU cores with <code class="docutils literal notranslate"><span class="pre">Trainer(accelerator=&quot;tpu&quot;,</span> <span class="pre">devices=8)</span></code> as predictions won’t be returned.</p>
<dl>
<dt>Args:</dt><dd><p>batch: The output of your data iterable, normally a <code class="xref py py-class docutils literal notranslate"><span class="pre">DataLoader</span></code>.
batch_idx: The index of this batch.
dataloader_idx: The index of the dataloader that produced this batch.</p>
<blockquote>
<div><p>(only if multiple dataloaders used)</p>
</div></blockquote>
</dd>
<dt>Return:</dt><dd><p>Predicted output (optional).</p>
</dd>
</dl>
<p>Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyModel</span><span class="p">(</span><span class="n">LightningModule</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch</span><span class="p">,</span> <span class="n">batch_idx</span><span class="p">,</span> <span class="n">dataloader_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>

<span class="n">dm</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">MyModel</span><span class="p">()</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">Trainer</span><span class="p">(</span><span class="n">accelerator</span><span class="o">=</span><span class="s2">&quot;gpu&quot;</span><span class="p">,</span> <span class="n">devices</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">trainer</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>in_channels</strong> (<em>int</em>)</p></li>
<li><p><strong>out_channels</strong> (<em>int</em>)</p></li>
<li><p><strong>loss_fn</strong> (<em>torch.nn.Module</em>)</p></li>
<li><p><strong>learning_rate</strong> (<em>float</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../loaders/index.html" class="btn btn-neutral float-left" title="minerva.models.loaders" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="base/index.html" class="btn btn-neutral float-right" title="minerva.models.nets.base" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Unicamp.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>